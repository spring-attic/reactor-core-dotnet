using Reactive.Streams;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Reactor.Core.publisher;
using Reactor.Core.subscriber;
using Reactor.Core.flow;
using Reactor.Core.scheduler;
using Reactor.Core.util;
using System.Threading.Tasks;
using System.Threading;

namespace Reactor.Core
{
    /// <summary>
    /// Extension methods for IFlux sources.
    /// </summary>
    public static class Flux
    {
        /// <summary>
        /// The default buffer size and prefetch amount.
        /// </summary>
        public static int BufferSize { get { return 128; } }

        // ---------------------------------------------------------------------------------------------------------
        // Enter the reactive world
        // ---------------------------------------------------------------------------------------------------------


        /// <summary>
        /// Create a new IPublisher that will only emit the passed data then onComplete.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="value">The unique data to emit</param>
        /// <returns>The new IPublisher instance</returns>
        public static IFlux<T> Just<T>(T value)
        {
            return new PublisherJust<T>(value);
        }

        /// <summary>
        /// Returns an empty instance which completes the ISubscribers immediately.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <returns>The shared Empty instance.</returns>
        public static IFlux<T> Empty<T>()
        {
            return PublisherEmpty<T>.Instance;
        }

        /// <summary>
        /// Returns an never instance which sets an empty ISubscription and
        /// does nothing further.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <returns>The shared Never instance.</returns>
        public static IFlux<T> Never<T>()
        {
            return PublisherNever<T>.Instance;
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(Func<T[], R> combiner, bool delayError = false, params IPublisher<T>[] sources)
        {
            return CombineLatest(combiner, BufferSize, delayError, sources);
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(Func<T[], R> combiner, int prefetch, bool delayError = false, params IPublisher<T>[] sources)
        {
            return new PublisherCombineLatest<T, R>(sources, null, prefetch, delayError, combiner);
        }

        /// <summary>
        /// Boxes or casts a value to object.
        /// </summary>
        /// <typeparam name="T">The input value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <returns>The IFlux instance.</returns>
        static IFlux<object> Box<T>(IPublisher<T> source)
        {
            return new PublisherMap<T, object>(source, v => (object)v);
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, R>(IPublisher<T1> p1, IPublisher<T2> p2, Func<T1, T2, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
                {
                    return combiner((T1)a[0], (T2)a[1]);
                }, 
                BufferSize, delayError, 
                Box(p1), Box(p2)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3,
            Func<T1, T2, T3, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="T4">The fourth source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <param name="p4">The fourth source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, T4, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3, IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3), Box(p4)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="T4">The fourth source's value type.</typeparam>
        /// <typeparam name="T5">The fifth source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <param name="p4">The fourth source.</param>
        /// <param name="p5">The fifth source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, T4, T5, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3, IPublisher<T4> p4,
            IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T1">The first source's value type.</typeparam>
        /// <typeparam name="T2">The second source's value type.</typeparam>
        /// <typeparam name="T3">The third source's value type.</typeparam>
        /// <typeparam name="T4">The fourth source's value type.</typeparam>
        /// <typeparam name="T5">The fifth source's value type.</typeparam>
        /// <typeparam name="T6">The sixth source's value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="p1">The first source.</param>
        /// <param name="p2">The second source.</param>
        /// <param name="p3">The third source.</param>
        /// <param name="p4">The fourth source.</param>
        /// <param name="p5">The fifth source.</param>
        /// <param name="p6">The sixth source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T1, T2, T3, T4, T5, T6, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T3> p3, IPublisher<T4> p4,
            IPublisher<T5> p5, IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> combiner, bool delayError = false)
        {
            return CombineLatest<object, R>(a =>
            {
                return combiner((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5]);
            },
                BufferSize, delayError,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5), Box(p6)
            );
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> combiner, bool delayError = false)
        {
            return CombineLatest(sources, combiner, BufferSize);
        }

        /// <summary>
        /// Build a IFlux whose data are generated by the combination of the most recent published values from all
        /// publishers.
        /// </summary>
        /// <remarks>
        /// Marble diagram:
        /// https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/combinelatest.png
        /// </remarks>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="combiner">The function that will receive the latest values from all sources and has to produce an output value.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The input IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> CombineLatest<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> combiner, int prefetch, bool delayError = false)
        {
            return new PublisherCombineLatest<T, R>(null, sources, prefetch, delayError, combiner);
        }

        /// <summary>
        /// Concatenates an IEnumerable sequence of IPublisher sources, optionally delaying errors until
        /// all sources have terminated.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The IEnumerable sequence if IPublisher sources.</param>
        /// <param name="delayError">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(IEnumerable<IPublisher<T>> sources, bool delayError = false)
        {
            return new PublisherConcatEnumerable<T>(sources, delayError);
        }

        /// <summary>
        /// Concatenates an parameter array of IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence if IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return new PublisherConcatArray<T>(sources, delayErrors);
        }

        /// <summary>
        /// Concatenates a dynamic sequence of IPublisher sources, optionally delaying errors from the outer IPublisher
        /// and the inner IPublishers until the current IPublisher terminates or all IPublishers terminated.
        /// </summary>
        /// <remarks>
        /// The operator prefetches 2 elements from the outer IPublisher, keeping them ready for subscription
        /// once the current inner IPublisher terminates.
        /// </remarks>
        /// <remarks>
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic sequence of IPublisher sources.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(IPublisher<IPublisher<T>> sources, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return Concat(sources, 2, errorMode);
        }

        /// <summary>
        /// Concatenates a dynamic sequence of IPublisher sources, optionally delaying errors from the outer IPublisher
        /// and the inner IPublishers until the current IPublisher terminates or all IPublishers terminated, plus it
        /// allows specifying how many elements to prefetch from the outer IPublisher.
        /// </summary>
        /// <remarks>
        /// The operator keeps a low-watermark of 25% of the specified prefetch amount.
        /// </remarks>
        /// <remarks>
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic sequence of IPublisher sources.</param>
        /// <param name="prefetch">The number of items to prefetch from the outer IPublisher. If negative, the outer IPublisher is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Concat<T>(IPublisher<IPublisher<T>> sources, int prefetch, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return new PublisherConcatMap<IPublisher<T>, T>(sources, v => v, prefetch, errorMode);
        }

        /// <summary>
        /// Creates an IFlux which when subscribed to, calls the specified Action with a IFluxEmitter instance that takes
        /// care of signalling events and handling backpressure for the downstream.
        /// </summary>
        /// <typeparam name="T">The value type signalled.</typeparam>
        /// <param name="emitter">The action called for each incoming subscriber with an IFluxEmitter instance.</param>
        /// <param name="backpressure">Specifies how to handle downstream backpressure. See <see cref="BackpressureHandling"/> for values.</param>
        /// <returns>The new IFlux isntance.</returns>
        public static IFlux<T> Create<T>(Action<IFluxEmitter<T>> emitter, BackpressureHandling backpressure = BackpressureHandling.Error)
        {
            return new PublisherCreate<T>(emitter, backpressure);
        }

        /// <summary>
        /// Supply a IPublisher everytime subscribe is called on the returned flux. The passed supplier function
        /// will be invoked and it's up to the developer to choose to return a new instance of a IPublisher or reuse
        /// one effecitvely behaving like from(IPublisher).
        /// </summary>
        /// <typeparam name="T">The type of values passing through the IFlux.</typeparam>
        /// <param name="supplier">The IPublisher supplier function to call on subscribe.</param>
        /// <returns>A deferred IFlux.</returns>
        public static IFlux<T> Defer<T>(Func<IPublisher<T>> supplier)
        {
            return new PublisherDefer<T>(supplier);
        }

        /// <summary>
        /// Creates an IFlux instance which signals the given exception
        /// immediately (or when requested).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="ex">The exception to signal</param>
        /// <param name="whenRequested">Signal the exception when requested?</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Error<T>(Exception ex, bool whenRequested = false)
        {
            return new PublisherError<T>(ex, whenRequested);
        }

        /// <summary>
        /// Relays signals from that source IPublisher that signalled anything first (cancels or doesn't even
        /// subscribe to the rest).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The parameter array of IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> FirstEmitting<T>(params IPublisher<T>[] sources)
        {
            return new PublisherAmb<T>(sources, null);
        }

        /// <summary>
        /// Relays signals from that source IPublisher that signalled anything first (cancels or doesn't even
        /// subscribe to the rest).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> FirstEmitting<T>(IEnumerable<IPublisher<T>> sources)
        {
            return new PublisherAmb<T>(null, sources);
        }

        /// <summary>
        /// Expose the specified IPublisher with the IFlux API.
        /// </summary>
        /// <typeparam name="T">the source sequence type</typeparam>
        /// <param name="source">the source to decorate</param>
        /// <returns>The source or an new IFlux wrapper of it.</returns>
        public static IFlux<T> From<T>(IPublisher<T> source)
        {
            if (source is IFlux<T>)
            {
                return (IFlux<T>)source;
            }
            return new PublisherWrap<T>(source);
        }

        /// <summary>
        /// Emits the elements of the given parameter array.
        /// </summary>
        /// <typeparam name="T">The element type of the array.</typeparam>
        /// <param name="values">The array of values to emit.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> From<T>(params T[] values)
        {
            int n = values.Length;
            ;
            if (n == 0)
            {
                return Empty<T>();
            }
            else
            if (n == 1)
            {
                return Just(values[0]);
            }
            return new PublisherArray<T>(values);
        }

        /// <summary>
        /// Emits the elements of the given IEnumerable sequence.
        /// </summary>
        /// <typeparam name="T">The element type of the IEnumerable.</typeparam>
        /// <param name="enumerable">The IEnumerable source of elements to signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> From<T>(IEnumerable<T> enumerable)
        {
            return new PublisherEnumerable<T>(enumerable);
        }

        /// <summary>
        /// Wraps the specified IObservable into an IFlux and applies the specified backpressure strategy
        /// (IObservables don't support backpressure on their own).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IObservable instance.</param>
        /// <param name="backpressure">The backpressure strategy. See <see cref="BackpressureHandling"/> enum constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> From<T>(IObservable<T> source, BackpressureHandling backpressure = BackpressureHandling.Error)
        {
            return new PublisherFromObservable<T>(source, backpressure);
        }

        /// <summary>
        /// Creates a valueless IFlux instance from the task which
        /// signals when the task completes or fails.
        /// </summary>
        /// <param name="task">The tast to use as source.</param>
        /// <returns>The IFlux instance</returns>
        public static IFlux<Void> From(Task task)
        {
            return new PublisherFromTask(task);
        }

        /// <summary>
        /// Creates a IFlux instance from the task which
        /// signals a single value when the task completes or 
        /// signals an Exception if the task fails.
        /// </summary>
        /// <param name="task">The tast to use as source.</param>
        /// <returns>The IFlux instance</returns>
        public static IFlux<T> From<T>(Task<T> task)
        {
            return new PublisherFromTask<T>(task);
        }

        /// <summary>
        /// Executes the given action for each subscriber and completes
        /// or signals an Exception if the action threw.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="action">The action</param>
        /// <returns>The IMono instance</returns>
        public static IFlux<T> From<T>(Action action)
        {
            return new PublisherAction<T>(action);
        }

        /// <summary>
        /// Emits the value returned by the supplier function to each individual subscriber.
        /// </summary>
        /// <typeparam name="T">The emitted value type.</typeparam>
        /// <param name="supplier">The function that is called for each subscriber to return a value to be emitted.</param>
        /// <param name="nullMeansEmpty">If the supplier returns null, should that be considered as empty source?
        /// Note that value types don't have a notion of null and their default value is considered a normal value.</param>
        /// <returns></returns>
        public static IFlux<T> From<T>(Func<T> supplier, bool nullMeansEmpty = false)
        {
            return new PublisherFunc<T>(supplier, nullMeansEmpty);
        }

        /// <summary>
        /// Generates signals when the downstream requests values in a stateless manner.
        /// </summary>
        /// <remarks>
        /// The generator action is called as many times as the downstream amount.
        /// For example, a downstream request(2) will call the action twice.
        /// </remarks>
        /// <typeparam name="T">The generated value type.</typeparam>
        /// <param name="generator">The action called with an ISignalEmitter instance for each 
        /// subscriber and for each downstream request to generate the next value to emit or a 
        /// teriman signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Generate<T>(Action<ISignalEmitter<T>> generator)
        {
            return Generate<T, object>(() => default(object), (s, e) => { generator(e); return s; }, s => { });
        }

        /// <summary>
        /// Generates signals when the downstream requests values in a stateful manner.
        /// </summary>
        /// <remarks>
        /// The generator action is called as many times as the downstream amount.
        /// For example, a downstream request(2) will call the action twice.
        /// </remarks>
        /// <typeparam name="T">The generated value type.</typeparam>
        /// <typeparam name="S">The state type.</typeparam>
        /// <param name="stateSupplier">The function returning the initial state object or structure for each subscriber.</param>
        /// <param name="generator">The action called with the current state value and a ISignalEmitter instance for each 
        /// subscriber and for each downstream request to generate the next value to emit or a 
        /// teriman signal. The function's return value should be the new state (which is used the next time this function is called).</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Generate<T, S>(Func<S> stateSupplier, Func<S, ISignalEmitter<T>, S> generator)
        {
            return Generate(stateSupplier, generator, s => { });
        }

        /// <summary>
        /// Generates signals when the downstream requests values in a stateful manner.
        /// </summary>
        /// <remarks>
        /// The generator action is called as many times as the downstream amount.
        /// For example, a downstream request(2) will call the action twice.
        /// </remarks>
        /// <typeparam name="T">The generated value type.</typeparam>
        /// <typeparam name="S">The state type.</typeparam>
        /// <param name="stateSupplier">The function returning the initial state object or structure for each subscriber.</param>
        /// <param name="generator">The action called with the current state value and a ISignalEmitter instance for each 
        /// subscriber and for each downstream request to generate the next value to emit or a 
        /// teriman signal. The function's return value should be the new state (which is used the next time this function is called).</param>
        /// <param name="stateDisposer">The action to call to dispose the state generated/modified by the other functions. This function
        /// is called exactly once for each subscriber whenever the generator signals a terminal event or the sequence gets cancelled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Generate<T, S>(Func<S> stateSupplier, Func<S, ISignalEmitter<T>, S> generator, Action<S> stateDisposer)
        {
            return new PublisherGenerate<T, S>(stateSupplier, generator, stateDisposer);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity, running
        /// on the default timed scheduler.
        /// </summary>
        /// <param name="period">The period at which numbers are signalled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan period)
        {
            return Interval(period, period, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity, running
        /// on the specified timed scheduler.
        /// </summary>
        /// <param name="period">The period at which numbers are signalled.</param>
        /// <param name="scheduler">The scheduler to use for emitting each number.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan period, TimedScheduler scheduler)
        {
            return Interval(period, period, scheduler);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity and after the
        /// initial delay, running on the default timed scheduler.
        /// </summary>
        /// <param name="initialDelay">The initial delay before signalling 0.</param>
        /// <param name="period">The period at which subsequent numbers are signalled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan initialDelay, TimeSpan period)
        {
            return Interval(initialDelay, period, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Generates a sequence of long numbers, starting from 0, with the given periodicity and after the
        /// initial delay, running on the default timed scheduler.
        /// </summary>
        /// <param name="initialDelay">The initial delay before signalling 0.</param>
        /// <param name="period">The period at which numbers are signalled.</param>
        /// <param name="scheduler">The scheduler to use for emitting each number.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Interval(TimeSpan initialDelay, TimeSpan period, TimedScheduler scheduler)
        {
            return new PublisherInterval(initialDelay, period, scheduler);
        }

        /// <summary>
        /// Merges the values from the specified parameter array of source IPublishers, optionally delaying
        /// any of their errors until all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator merges at most <see cref="BufferSize"/> number of sources at once and uses
        /// <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The parameter array of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return Merge(BufferSize, BufferSize, delayErrors, sources);
        }

        /// <summary>
        /// Merges the values from the specified parameter array of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
        /// all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator uses <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The parameter array of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(int maxConcurrency, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return Merge(BufferSize, maxConcurrency, delayErrors, sources);
        }

        /// <summary>
        /// Merges the values from the specified parameter array of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
        /// optionally delaying any of their errors until all sources terminate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The parameter array of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(int maxConcurrency, int prefetch, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            // TODO implement Merge
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merges the values from the specified IEnumerable sequence of source IPublishers, optionally delaying
        /// any of their errors until all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator merges at most <see cref="BufferSize"/> number of sources at once and uses
        /// <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(IEnumerable<IPublisher<T>> sources, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, BufferSize, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified IEnumerable sequence of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
        /// all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator uses <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(IEnumerable<IPublisher<T>> sources, int maxConcurrency, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, maxConcurrency, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified IEnumerable sequence of source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
        /// optionally delaying any of their errors until all sources terminate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of sources to merge at once.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(IEnumerable<IPublisher<T>> sources, int maxConcurrency, int prefetch, bool delayErrors = false)
        {
            return From(sources).FlatMap(v => v, maxConcurrency, prefetch, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified dynamic outer IPublisher sequence of inner source IPublishers, optionally delaying
        /// any of their errors until all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator merges at most <see cref="BufferSize"/> number of sources at once and uses
        /// <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(this IPublisher<IPublisher<T>> sources, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, BufferSize, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified dynamic outer IPublisher sequence of inner source IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, optionally delaying any of their errors until
        /// all sources terminate.
        /// </summary>
        /// <remarks>
        /// The operator uses <see cref="BufferSize"/> prefetch for those sources.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of inner sources to merge at once.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(this IPublisher<IPublisher<T>> sources, int maxConcurrency = int.MaxValue, bool delayErrors = false)
        {
            return Merge(sources, BufferSize, maxConcurrency, delayErrors);
        }

        /// <summary>
        /// Merges the values from the specified dynamic outer IPublisher sequence of inner IPublishers, at most
        /// <paramref name="maxConcurrency"/> sources at once, using the specified prefetch for these sources,
        /// optionally delaying any of their errors until all sources terminate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="maxConcurrency">The maximum number of inner sources to merge at once.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, errors are delayed until all all source IPublishers have terminated.
        /// If multiple sources terminate with an OnError signal, the downstream will receive an AggregateException containing all
        /// Exceptions</param>
        /// <param name="sources">The dynamic outer IPublisher of inner IPublisher sources to merge.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Merge<T>(this IPublisher<IPublisher<T>> sources, int prefetch, int maxConcurrency = int.MaxValue, bool delayErrors = false)
        {
            return new PublisherFlatMap<IPublisher<T>, T>(sources, v => v, delayErrors, maxConcurrency, prefetch);
        }

        /// <summary>
        /// Signals a range of values from start to start + count (exclusive).
        /// </summary>
        /// <param name="start">The start value</param>
        /// <param name="count">The number of items, non-negative</param>
        /// <returns></returns>
        public static IFlux<int> Range(int start, int count)
        {
            if (count == 0)
            {
                return Empty<int>();
            }
            else
            if (count == 1)
            {
                return Just(start);
            }
            return new PublisherRange(start, count);
        }

        /// <summary>
        /// Creates an IFluxProcessor that accepts IPublisher instances, subscribes to them and
        /// relays signals from them until the next IPublisher is signalled to the IFluxProcessor.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <returns>The new IFluxProcessor instance.</returns>
        public static IFluxProcessor<IPublisher<T>, T> SwitchOnNext<T>()
        {
            return SwitchOnNext<T>(BufferSize);
        }

        /// <summary>
        /// Creates an IFluxProcessor that accepts IPublisher instances, subscribes to them and
        /// relays signals from them until the next IPublisher is signalled to the IFluxProcessor.
        /// Each IPublisher instance is prefetched with the specified amount and using a low-watermark
        /// of 25%.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFluxProcessor instance.</returns>
        public static IFluxProcessor<IPublisher<T>, T> SwitchOnNext<T>(int prefetch)
        {
            // TODO implement SwitchOnNext
            throw new NotImplementedException();
        }

        /// <summary>
        /// Relays signals of the inner IPublisher sources until the outer IPublisher produces another inner source.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic IPublisher sequence of inner IPublisher sources.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SwitchOnNext<T>(this IPublisher<IPublisher<T>> sources)
        {
            return SwitchOnNext<T>(sources, BufferSize);
        }

        /// <summary>
        /// Relays signals of the inner IPublisher sources until the outer IPublisher produces another inner source.
        /// It uses the given prefetch amount on the inner IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="sources">The dynamic IPublisher sequence of inner IPublisher sources.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns></returns>
        public static IFlux<T> SwitchOnNext<T>(this IPublisher<IPublisher<T>> sources, int prefetch)
        {
            return new PublisherSwitchMap<IPublisher<T>, T>(sources, v => v, prefetch);
        }

        /// <summary>
        /// Signals a single long 0 after the specified delay on the default timed scheduler.
        /// </summary>
        /// <param name="delay">The delay amount.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Timer(TimeSpan delay)
        {
            return Timer(delay, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Signals a single long 0 after the specified delay on the specified timed scheduler.
        /// </summary>
        /// <param name="delay">The delay amount.</param>
        /// <param name="scheduler">The target timed scheduler.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<long> Timer(TimeSpan delay, TimedScheduler scheduler)
        {
            return new PublisherTimer(delay, scheduler);
        }

        /// <summary>
        /// Uses a generated resource, derives an IPublisher from it whose signals are relayed and
        /// disposes the generated resource once the IPublisher terminates or gets cancelled.
        /// </summary>
        /// <typeparam name="T">The value type signalled.</typeparam>
        /// <typeparam name="S">The resource type.</typeparam>
        /// <param name="resourceSupplier">Function that returns a resource for each subscriber</param>
        /// <param name="publisherFactory">Function that receives the generated resource and returns an IPublisher to be relayed for each subscriber.</param>
        /// <param name="resourceDisposer">The action called to dispose the generated resource.</param>
        /// <param name="eager">If true, the resourceDisposer is called before signalling the terminal event; after otherwise.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Using<T, S>(Func<S> resourceSupplier, Func<S, IPublisher<T>> publisherFactory, Action<S> resourceDisposer, bool eager = true)
        {
            return new PublisherUsing<T, S>(resourceSupplier, publisherFactory, resourceDisposer, eager);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source, through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The parameter array of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(Func<T[], R> zipper, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            return Zip(zipper, BufferSize, delayErrors, sources);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source, through a function and emits the resulting value
        /// while prefetching the given amount from each of these IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The parameter array of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(Func<T[], R> zipper, int prefetch, bool delayErrors = false, params IPublisher<T>[] sources)
        {
            // TODO implement Using
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source from the IEnumerable sequence,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> zipper, bool delayErrors = false)
        {
            return Zip(sources, zipper, BufferSize);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source from the IEnumerable sequence,
        /// through a function and emits the resulting value
        /// while prefetching the given amount from each of these IPublisher sources.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <param name="sources">The IEnumerable sequence of IPublisher sources to combine.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T, R>(IEnumerable<IPublisher<T>> sources, Func<T[], R> zipper, int prefetch, bool delayErrors = false)
        {
            // TODO implement Zip
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        public static IFlux<R> Zip<T1, T2, R>(IPublisher<T1> p1, IPublisher<T2> p2, Func<T1, T2, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, R>(IPublisher<T1> p1, IPublisher<T2> p2, Func<T1, T2, R> zipper, int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3,
            Func<T1, T2, T3, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3,
            Func<T1, T2, T3, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, p4, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3), Box(p4)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, p4, p5, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5)
            );
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="T6">The sixth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="p6">The sixth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, T6, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5, IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> zipper, bool delayErrors = false)
        {
            return Zip(p1, p2, p3, p4, p5, p6, zipper, BufferSize, delayErrors);
        }

        /// <summary>
        /// Combines a row of values, the next from each IPublisher source,
        /// through a function and emits the resulting value.
        /// </summary>
        /// <typeparam name="T1">The first input value type.</typeparam>
        /// <typeparam name="T2">The second input value type.</typeparam>
        /// <typeparam name="T3">The third input value type.</typeparam>
        /// <typeparam name="T4">The fourth input value type.</typeparam>
        /// <typeparam name="T5">The fifth input value type.</typeparam>
        /// <typeparam name="T6">The sixth input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="p1">The first source IPublisher.</param>
        /// <param name="p2">The second source IPublisher.</param>
        /// <param name="p3">The third source IPublisher.</param>
        /// <param name="p4">The fourth source IPublisher.</param>
        /// <param name="p5">The fifth source IPublisher.</param>
        /// <param name="p6">The sixth source IPublisher.</param>
        /// <param name="zipper">The function that receives an array of values, as many as there are sources and returns
        /// a value to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Zip<T1, T2, T3, T4, T5, T6, R>(
            IPublisher<T1> p1, IPublisher<T2> p2,
            IPublisher<T2> p3, IPublisher<T4> p4,
            IPublisher<T5> p5, IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> zipper,
            int prefetch, bool delayErrors = false)
        {
            return Zip<object, R>(a =>
            {
                return zipper((T1)a[0], (T2)a[1], (T3)a[2], (T4)a[3], (T5)a[4], (T6)a[5]);
            },
                BufferSize, delayErrors,
                Box(p1), Box(p2), Box(p3), Box(p4), Box(p5), Box(p6)
            );
        }

        // ---------------------------------------------------------------------------------------------------------
        // Transform the reactive world
        // ---------------------------------------------------------------------------------------------------------

        /// <summary>
        /// Transform the items emitted by this IFlux by applying a function to each item.
        /// </summary>
        /// <typeparam name="T">The input value type</typeparam>
        /// <typeparam name="R">The output value type</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="mapper">The mapper from Ts to Rs</param>
        /// <returns>The new IFlux instance</returns>
        public static IFlux<R> Map<T, R>(this IFlux<T> source, Func<T, R> mapper)
        {
            return new PublisherMap<T, R>(source, mapper);
        }

        /// <summary>
        /// Apply the transformer function on the source IFlux; this allows fluent conversion
        /// to any other type.
        /// </summary>
        /// <typeparam name="T">The input IFlux value type.</typeparam>
        /// <typeparam name="R">The output type.</typeparam>
        /// <param name="source">The source IFlux to transform.</param>
        /// <param name="transformer">The transformer, receiving the IFlux source and returns a value.</param>
        /// <returns>The value returned by the transformer function.</returns>
        public static R As<T, R>(this IFlux<T> source, Func<IFlux<T>, R> transformer)
        {
            return transformer(source);
        }

        /// <summary>
        /// Returns an IMono containing true if the source contains any item the predicate
        /// matches.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate to apply to each item in the sequence.</param>
        /// <returns>The new IMono containing either true or false.</returns>
        public static IMono<bool> Any<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement Any
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns an IMono containing true if all items from the source match the predicate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate to be mached by all source elements.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<bool> All<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement All
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers all elements from the source sequence into an IList.
        /// This operator requires a finite source.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance holding the IList of all source values.</returns>
        public static IMono<IList<T>> Buffer<T>(this IFlux<T> source)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers with the specified number of elements in
        /// each.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="size">The size of each IList buffer (except the last once which could be smaller).</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int size)
        {
            return Buffer(source, size, size);
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers with the specified number of elements in
        /// each and sub-buffers started after the skip amount.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="size">The number of elements to store in each sub-buffer.</param>
        /// <param name="skip">The number of elements to let pass to start the next buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int size, int skip)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers whose boundary is established by
        /// an OnNext signal from the boundary IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The boundary value type.</typeparam>
        /// <param name="source">The source IFlux of values to buffer.</param>
        /// <param name="boundary">The boundary IPublisher signalling the end and start of each sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T, U>(this IFlux<T> source, IPublisher<U> boundary)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers which are opened by an IPublisher
        /// and closed by another, derived IPublisher signalling.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The buffer-opening sequence type.</typeparam>
        /// <typeparam name="V">The buffer-closing sequence type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="open">The IPublisher opening buffers</param>
        /// <param name="close">The function generating an IPublisher to close a buffer opened 
        /// by the value from <paramref name="open"/> sequence.</param>
        /// <returns>The nex IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T, U, V>(this IFlux<T> source, IPublisher<U> open, Func<U, IPublisher<V>> close)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers for the specified timespan duration each.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time duration for each sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Buffer(source, timespan, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Buffers elements into non-overlapping sub-buffers for the specified timespan duration each,
        /// determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time duration for each sub-buffer.</param>
        /// <param name="scheduler">The timed scheduler to give the notion of time for the sub-buffer duration</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            return Buffer(source, timespan, timespan, scheduler);
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers, buffering for the specified timespan each
        /// and starting new buffers after the specified timeskip time.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The duration for each sub-buffer.</param>
        /// <param name="timeskip">The time to skip before starting a new sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip)
        {
            return Buffer(source, timespan, timeskip, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Buffers elements into potentially overlapping sub-buffers, buffering for the specified timespan each
        /// and starting new buffers after the specified timeskip time, as determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The duration for each sub-buffer.</param>
        /// <param name="timeskip">The time to skip before starting a new sub-buffer.</param>
        /// <param name="scheduler">The timed scheduler to provide the timing of sub-buffer boundaries.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip, TimedScheduler scheduler)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Buffer elements into non-overlapping sub-buffers limited by a maximum size or buffering duration.
        /// If the maximum size is reached, the time duration is restarted from that point.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="maxSize">The maximum number of elements in each sub-buffer.</param>
        /// <param name="timespan">The duration of buffering into each sub-buffer.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int maxSize, TimeSpan timespan)
        {
            return Buffer(source, maxSize, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Buffer elements into non-overlapping sub-buffers limited by a maximum size or buffering duration.
        /// If the maximum size is reached, the time duration is restarted from that point,
        /// where timing is determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="maxSize">The maximum number of elements in each sub-buffer.</param>
        /// <param name="timespan">The duration of buffering into each sub-buffer.</param>
        /// <param name="scheduler">The timed scheduler to provide the timing of sub-buffer boundaries.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IList<T>> Buffer<T>(this IFlux<T> source, int maxSize, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Buffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Caches all (or the last <paramref name="history"/>) elements from the source IFlux and
        /// replays them to every subscriber. The caching starts when the first subscriber subscribes.
        /// </summary>
        /// <remarks>
        /// The cache can't be cleared or restarted. See <see cref="Replay{T}(IFlux{T})"/> to.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source sequence.</param>
        /// <param name="history">The number of elements to retain.</param>
        /// <returns>The IFlux instance.</returns>
        public static IFlux<T> Cache<T>(this IFlux<T> source, int history = int.MaxValue)
        {
            // TODO implement Cache
            throw new NotImplementedException();
        }

        /// <summary>
        /// Casts elements of the source sequence into the given type or
        /// signals InvalidCastException if any of the source elements can't
        /// be cast to that target type.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The target value type.</typeparam>
        /// <param name="source">The source sequence.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Cast<T, R>(this IFlux<T> source) where T: class where R: class
        {
            return Map(source, v =>
            {
                R r = v as R;
                if (v != null && r == null)
                {
                    throw new InvalidCastException();
                }
                return r;
            });
        }

        /// <summary>
        /// Collects values into a custom collection, provided by a factory for each subscriber,
        /// via a collector action and emits this collection at the end.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="C">The collection type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="collectionSupplier">The supplier of the collection.</param>
        /// <param name="collector">The action called with the collection and the current source value.</param>
        /// <returns>The new IMono instance with the collection.</returns>
        public static IMono<C> Collect<T, C>(this IFlux<T> source, Func<C> collectionSupplier, Action<C, T> collector)
        {
            return new PublisherCollect<T, C>(source, collectionSupplier, collector);
        }

        /// <summary>
        /// Collects all source values into an IList and returns it as an IMono.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="capacityHint">The expected number of elements. (Reduce number of times the list has to be resized).</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IList<T>> CollectList<T>(this IFlux<T> source, int capacityHint = 16)
        {
            return Collect<T, IList<T>>(source, () => new List<T>(capacityHint), (c, t) => c.Add(t));
        }

        /// <summary>
        /// Collects all source values into an sorted IList and returns it as an IMono.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="comparer">The comparer function to compare elements.</param>
        /// <param name="capacityHint">The expected number of elements. (Reduce number of times the list has to be resized).</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IList<T>> CollectSortedList<T>(this IFlux<T> source, IComparer<T> comparer, int capacityHint = 16)
        {
            return CollectList(source, capacityHint).Map(c => c.OrderBy(v => v, comparer).ToList());
        }

        /// <summary>
        /// Collects all values into a Dictionary where the keys are derived via function.
        /// </summary>
        /// <remarks>
        /// Source values mapping to the same key are overwritten.
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source values.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, T>> CollectDictionary<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return CollectDictionary(source, keySelector, v => v);
        }

        /// <summary>
        /// Collects all values into a Dictionary where the keys and values are derived via functions.
        /// </summary>
        /// <remarks>
        /// Source values mapping to the same key are overwritten.
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source element.</param>
        /// <param name="valueSelector">The function that extracts the value from the source element</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, V>> CollectDictionary<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector)
        {
            return Collect<T, IDictionary<K, V>>(source, () => new Dictionary<K, V>(), (d, t) =>
            {
                var k = keySelector(t);
                if (d.ContainsKey(k))
                {
                    d[k] = valueSelector(t);
                }
                else
                {
                    d.Add(k, valueSelector(t));
                }
            });
        }

        /// <summary>
        /// Collects elements mapping to the same key through a function into a list in a dictionary.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source element.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, IList<T>>> CollectMultiDictionary<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return CollectMultiDictionary(source, keySelector, v => v);
        }

        /// <summary>
        /// Collects elements, transformed by a function, mapping to the same key through a function into a list in a dictionary.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source element.</param>
        /// <param name="valueSelector">The function that extracts the value from each source element.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<IDictionary<K, IList<V>>> CollectMultiDictionary<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector)
        {
            return Collect<T, IDictionary<K, IList<V>>>(source, () => new Dictionary<K, IList<V>>(), (d, t) =>
            {
                var k = keySelector(t);
                if (d.ContainsKey(k))
                {
                    var list = d[k];
                    list.Add(valueSelector(t));
                }
                else
                {
                    var list = new List<V>();
                    list.Add(valueSelector(t));
                    d.Add(k, list);
                }
            });
        }

        /// <summary>
        /// Transforms the source IFlux into an IPublisher at subscription time (for each subscriber), allowing
        /// custom behavior to be injected into a flow.
        /// </summary>
        /// <remarks>
        /// Because the function is called at subscription time, the composition can have sequence-local
        /// state associated. 
        /// <p/>
        /// To do an assembly time composition, use the <see cref="As{T, R}(IFlux{T}, Func{IFlux{T}, R})"/>
        /// operator with a IPublisher-returning function.
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The output value type</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="composer">The function called for each subscriber, receiving the source and returning
        /// an IPublisher that will be subscribed to.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Compose<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> composer)
        {
            return Defer(() => composer(source));
        }

        /// <summary>
        /// Concatenates IPublishers generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IPublisher.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ConcatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return ConcatMap(source, mapper, BufferSize, errorMode);
        }

        /// <summary>
        /// Concatenates IPublishers generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IPublisher.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ConcatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int prefetch, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return new PublisherConcatMap<T, R>(source, mapper, prefetch, errorMode);
        }

        /// <summary>
        /// Concatenates IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> ConcatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            return ConcatMap(source, mapper, BufferSize, errorMode);
        }

        /// <summary>
        /// Concatenates IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="errorMode">Specifies the error handling behavior. See <see cref="ConcatErrorMode"/> constants.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> ConcatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper, int prefetch, ConcatErrorMode errorMode = ConcatErrorMode.Immediate)
        {
            // TODO implement ConcatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Concatenates the source IFlux sequence with the other IPublisher sequence, optionally delaying an OnError signal
        /// from the first one until the other sequence terminates.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher sequence</param>
        /// <param name="delayError">If true, OnError signals are delayed until the other IPublisher sequence terminates.
        /// If both signal an OnError, the sequence signals an AggregateException of the two Exceptions.</param>
        /// <returns></returns>
        public static IFlux<T> ConcatWith<T>(this IFlux<T> source, IFlux<T> other, bool delayError = false)
        {
            if (source is PublisherConcatArray<T>)
            {
                return (source as PublisherConcatArray<T>).EndWith(source, delayError);
            }
            return new PublisherConcatArray<T>(new IPublisher<T>[] { source, other }, delayError);
        }

        /// <summary>
        /// Counts the number if elements in the IFlux sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<long> Count<T>(this IFlux<T> source)
        {
            return new PublisherCount<T>(source);
        }

        /// <summary>
        /// Signals a default value if the source IFlux sequence is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="defaultValue">The default value to signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DefaultIfEmpty<T>(this IFlux<T> source, T defaultValue)
        {
            // TODO implement DefaultIfEmpty
            throw new NotImplementedException();
        }

        /// <summary>
        /// Shifts the emission of the source IPublisher signals in time by the given amount,
        /// determined by the default timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The shift amount.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Delay<T>(this IFlux<T> source, TimeSpan delay)
        {
            // TODO implement Delay
            throw new NotImplementedException();
        }

        /// <summary>
        /// Shifts the emission of the source IPublisher signals in time by the given amount,
        /// determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The shift amount.</param>
        /// <param name="scheduler">The timed scheduler to use for the time shifting.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Delay<T>(this IFlux<T> source, TimeSpan delay, TimedScheduler scheduler)
        {
            // TODO implement Delay
            throw new NotImplementedException();
        }

        /// <summary>
        /// Delays the actual subscription to the source IFlux instance until the specified delay
        /// has elapsed, as determined by the default timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The delay amount</param>
        /// <returns>The new IFlux instance</returns>
        public static IFlux<T> DelaySubscription<T>(this IFlux<T> source, TimeSpan delay)
        {
            // TODO implement DelaySubscription
            throw new NotImplementedException();
        }

        /// <summary>
        /// Delays the actual subscription to the source IFlux instance until the specified delay
        /// has elapsed, as determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="delay">The delay amount</param>
        /// <param name="scheduler">The timed scheduler to use for the time shifting.</param>
        /// <returns>The new IFlux instance</returns>
        public static IFlux<T> DelaySubscription<T>(this IFlux<T> source, TimeSpan delay, TimedScheduler scheduler)
        {
            // TODO implement DelaySubscription
            throw new NotImplementedException();
        }

        /// <summary>
        /// Delays the actual subscription to the source IFlux until the other IPublisher signals an
        /// OnNext or OnComplete.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The other value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher which should trigger the actual subscription.</param>
        /// <returns></returns>
        public static IFlux<T> DelaySubscription<T, U>(this IFlux<T> source, IPublisher<U> other)
        {
            // TODO implement DelaySubscription
            throw new NotImplementedException();
        }

        /// <summary>
        /// Transforms a sequence of ISignal instances back into OnNext, OnError and OnComplete signals.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux with ISignal type.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Dematerialize<T>(this IFlux<ISignal<T>> source)
        {
            // TODO implement Dematerialize
            throw new NotImplementedException();
        }

        /// <summary>
        /// Makes sure only distinct elements are relayed through the lifetime of the IFlux sequence,
        /// as determined by the default <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen elements can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T>(this IFlux<T> source)
        {
            return Distinct(source, v => v, EqualityComparer<T>.Default);
        }

        /// <summary>
        /// Makes sure only distinct elements are relayed through the lifetime of the IFlux sequence,
        /// as determined by the given comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen elements can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="comparer">The comparer comparing the source elements</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T>(this IFlux<T> source, IEqualityComparer<T> comparer)
        {
            return Distinct(source, v => v, comparer);
        }

        /// <summary>
        /// Makes sure only distinct elements (according to a key) are relayed through the lifetime of the IFlux sequence,
        /// as determined by the <see cref="EqualityComparer{T}.Default"/> key comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen keys can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source value to be checked for distinctness.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return Distinct(source, keySelector, EqualityComparer<K>.Default);
        }

        /// <summary>
        /// Makes sure only distinct elements (according to a key) are relayed through the lifetime of the IFlux sequence,
        /// as determined by the given comparer. default <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <remarks>
        /// Note that the internal HashSet used for remembering seen keys can't be cleared
        /// and may grow indefinitely.
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts the key from the source value to be checked for distinctness.</param>
        /// <param name="comparer">The comparer comparing the extracted keys.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Distinct<T, K>(this IFlux<T> source, Func<T, K> keySelector, IEqualityComparer<K> comparer)
        {
            return new PublisherDistinct<T, K>(source, keySelector, comparer);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if it doesn't equal to the previous
        /// element, based on the default <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T>(this IFlux<T> source)
        {
            return DistinctUntilChanged(source, v => v, EqualityComparer<T>.Default);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if it doesn't equal to the previous
        /// element, based on the give comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="comparer">The comparer to compare subsequent source items.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T>(this IFlux<T> source, IEqualityComparer<T> comparer)
        {
            return DistinctUntilChanged(source, v => v, comparer);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if the key extracted from it doesn't equal to the previous
        /// element's key, based on the default <see cref="EqualityComparer{T}.Default"/> key comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from the source item.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return DistinctUntilChanged(source, keySelector, EqualityComparer<K>.Default);
        }

        /// <summary>
        /// Makes sure a source IFlux item is only relayed if the key extracted from it doesn't equal to the previous
        /// element's key, based on the given key comparer.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from the source item.</param>
        /// <param name="comparer">The comparer to compare the extracted keys of subsequent source items.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DistinctUntilChanged<T, K>(this IFlux<T> source, Func<T, K> keySelector, IEqualityComparer<K> comparer)
        {
            return new PublisherDistinctUntilChanged<T, K>(source, keySelector, comparer);
        }

        /// <summary>
        /// Call the specified action after the source has signalled an OnError or OnComplete.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onAfterTerminate">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoAfterTerminate<T>(this IFlux<T> source, Action onAfterTerminate)
        {
            return PublisherPeek<T>.withOnAfterTerminate(source, onAfterTerminate);
        }

        /// <summary>
        /// Call the specified action with the current value after the source has signalled an OnNext.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onAfterNext">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoAfterNext<T>(this IFlux<T> source, Action<T> onAfterNext)
        {
            return PublisherPeek<T>.withOnAfterNext(source, onAfterNext);
        }

        /// <summary>
        /// Call the specified action if the sequence gets cancelled.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onCancel">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnCancel<T>(this IFlux<T> source, Action onCancel)
        {
            return PublisherPeek<T>.withOnCancel(source, onCancel);
        }

        /// <summary>
        /// Call the specified action before the source signals an OnComplete.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onComplete">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>

        public static IFlux<T> DoOnComplete<T>(this IFlux<T> source, Action onComplete)
        {
            return PublisherPeek<T>.withOnComplete(source, onComplete);
        }

        /// <summary>
        /// Call the specified action before the source signals an OnError.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onError">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnError<T>(this IFlux<T> source, Action<Exception> onError)
        {
            return PublisherPeek<T>.withOnError(source, onError);
        }

        /// <summary>
        /// Call the specified action before the source signals OnError with the given Exception type (or its subtypes).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="E">The exception type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onError">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnError<T, E>(this IFlux<T> source, Action<E> onError) where E : Exception
        {
            return DoOnError(source, e =>
            {
                if (e is E)
                {
                    onError(e as E);
                }
            });
        }

        /// <summary>
        /// Call the specified action before the source signals an OnError whose Exception matches the predicate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate that receives the Exception and if returns true, the onError action is called.</param>
        /// <param name="onError">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnError<T>(this IFlux<T> source, Func<Exception, bool> predicate, Action<Exception> onError)
        {
            return DoOnError(source, e =>
            {
                if (predicate(e))
                {
                    onError(e);
                }
            });
        }

        /// <summary>
        /// Calls the specified action with the current value before the sequence signals an OnNext.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="onNext">The action to call with the current value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnNext<T>(this IFlux<T> source, Action<T> onNext)
        {
            return PublisherPeek<T>.withOnNext(source, onNext);
        }

        /// <summary>
        /// Calls the specified action with the current request amount before it reaches the upstream.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="onRequest">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnRequest<T>(this IFlux<T> source, Action<long> onRequest)
        {
            return PublisherPeek<T>.withOnRequest(source, onRequest);
        }

        /// <summary>
        /// Calls the specified action with the incoming ISubscription before it reaches the downstream.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onSubscribe">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnSubscribe<T>(this IFlux<T> source, Action<ISubscription> onSubscribe)
        {
            return PublisherPeek<T>.withOnSubscribe(source, onSubscribe);
        }

        /// <summary>
        /// Calls the specified action befoer the source signals an OnError or OnComplete.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onTerminate">The action to call.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> DoOnTerminate<T>(this IFlux<T> source, Action onTerminate)
        {
            return PublisherPeek<T>.withOnTerminate(source, onTerminate);
        }

        /// <summary>
        /// Wraps each source element into a Timed structure which holds the time difference between
        /// subsequent element according to the default timed scheduler. The first structure holds
        /// the time between the subscription and the emission of the first element.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<Timed<T>> Elapsed<T>(this IFlux<T> source)
        {
            return Elapsed(source, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Wraps each source element into a Timed structure which holds the time difference between
        /// subsequent element according to the given timed scheduler. The first structure holds
        /// the time between the subscription and the emission of the first element.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="scheduler">The scheduler supplying the notion of current time.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<Timed<T>> Elapsed<T>(this IFlux<T> source, TimedScheduler scheduler)
        {
            // TODO implement Elapsed
            throw new NotImplementedException();
        }

        /// <summary>
        /// Emits the element at the given index or signals an IndexOutOfRangeException if
        /// the sequence is shorter.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="index">The index of the element to return.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IMono<T> ElementAt<T>(this IFlux<T> source, long index)
        {
            // TODO implement ElementAt
            throw new NotImplementedException();
        }

        /// <summary>
        /// Emits the element at the given index or signals a default value if
        /// the sequence is shorter.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="index">The index of the element to return.</param>
        /// <param name="defaultValue">The value to signal if the sequence is shorter.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IMono<T> ElementAt<T>(this IFlux<T> source, long index, T defaultValue)
        {
            // TODO implement ElementAt
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns every <paramref name="batchSize"/> element from the source sequence
        /// or the very last element (if the source length not multiple of the batchSize).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="batchSize">The frequency of elements to return.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Every<T>(this IFlux<T> source, int batchSize)
        {
            return source.Window(batchSize).FlatMap(w => w.Last());
        }

        /// <summary>
        /// Returns every <paramref name="batchSize"/> element, starting from the first element from
        /// the source sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="batchSize">The frequency of elements to return.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> EveryFirst<T>(this IFlux<T> source, int batchSize)
        {
            return source.Window(batchSize).FlatMap(w => w.Next());
        }

        /// <summary>
        /// Filters out elements that don't match the predicate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="predicate">The predicate function called for each source element and returns true if that element
        /// may pass.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Filter<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            return new PublisherFilter<T>(source, predicate);
        }

        /// <summary>
        /// Relays signals of the source IFlux or the other IPublisher sequence whichever signals first,
        /// cancelling the other (or not even subscribing to it).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> FirstEmittingWith<T>(this IFlux<T> source, IPublisher<T> other)
        {
            if (source is PublisherAmb<T>)
            {
                var a = (source as PublisherAmb<T>).AmbWith(other);
                if (a != null)
                {
                    return a;
                }
            }
            return FirstEmitting<T>(source, other);
        }

        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, optionally
        /// delaying any errors.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, bool delayErrors = false)
        {
            return FlatMap(source, mapper, BufferSize, BufferSize, delayErrors);
        }

        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, 
        /// making sure only the specified number of sources are active and optionally
        /// delaying any errors.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
        /// <param name="maxConcurrency">The maximum number of active IPublisher sources at the same time.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int maxConcurrency, bool delayErrors = false)
        {
            return FlatMap(source, mapper, maxConcurrency, BufferSize, delayErrors);
        }

        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements, 
        /// making sure only the specified number of sources are active, prefetching the specified amount from each
        /// and optionally delaying any errors.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives a source value and returns an IPublisher to be merged</param>
        /// <param name="maxConcurrency">The maximum number of active IPublisher sources at the same time.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayErrors">If true, Exceptions from OnError signals are delayed until all sources have terminated,
        /// signalling an AggregateException if there were more than one Exception.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int maxConcurrency, int prefetch, bool delayErrors = false)
        {
            return new PublisherFlatMap<T, R>(source, mapper, delayErrors, maxConcurrency, prefetch);
        }


        /// <summary>
        /// Flattens (merges) a sequence of IPublisher sources generated via a mapper function from the source elements and terminal signals.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapperOnNext">The function that receives each source elements and returns an IPublisher for them to be merged.</param>
        /// <param name="mapperOnError">The function that receives the Exception and returns an IPublisher for it to be merged.</param>
        /// <param name="mapperOnComplete">The function that is called when the source completes and returns an IPublisher for it to be merged.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapperOnNext, 
            Func<Exception, IPublisher<R>> mapperOnError, Func<IPublisher<R>> mapperOnComplete)
        {
            // TODO implement FlatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Flattens (merges) IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper)
        {
            // TODO implement FlatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Flattens (merges) IEnumerable sequences generated by a mapper function from the values of the source IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that maps each source value into an IEnumerable.</param>
        /// <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> FlatMap<T, R>(this IFlux<T> source, Func<T, IEnumerable<R>> mapper, int prefetch)
        {
            // TODO implement FlatMap
            throw new NotImplementedException();
        }

        /// <summary>
        /// Groups elements with the same key into an IGroupedFlux inner sequences.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from a source element.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<K, T>> GroupBy<T, K>(this IFlux<T> source, Func<T, K> keySelector)
        {
            return GroupBy(source, keySelector, v => v, BufferSize);
        }

        /// <summary>
        /// Groups values, extracted from elements, with the same key into IGroupedFlux inner sequences.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from a source element.</param>
        /// <param name="valueSelector">The function that extracts the value from a source element.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<K, V>> GroupBy<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector)
        {
            return GroupBy(source, keySelector, valueSelector, BufferSize);
        }

        /// <summary>
        /// Groups values, extracted from elements, with the same key into IGroupedFlux inner sequences.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="K">The key type.</typeparam>
        /// <typeparam name="V">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="keySelector">The function that extracts a key from a source element.</param>
        /// <param name="valueSelector">The function that extracts the value from a source element.</param>
        /// <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<K, V>> GroupBy<T, K, V>(this IFlux<T> source, Func<T, K> keySelector, Func<T, V> valueSelector, int prefetch)
        {
            // TODO implement GroupBy
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals a single true if the source has the specified element, based on
        /// the <see cref="EqualityComparer{T}.Default"/> comparer.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="element">The element to look for.</param>
        /// <returns>The new IMono instance</returns>
        public static IMono<bool> HasElement<T>(this IFlux<T> source, T element)
        {
            return HasElement(source, element, EqualityComparer<T>.Default);
        }

        /// <summary>
        /// Signals a single true if the source has the specified element, based on
        /// the given comparer.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="element">The element to look for.</param>
        /// <param name="comparer">The comparer to use to compare source elements with the given element.</param>
        /// <returns>The new IMono instance</returns>
        public static IMono<bool> HasElement<T>(this IFlux<T> source, T element, IEqualityComparer<T> comparer)
        {
            return Any(source, v => comparer.Equals(v, element));
        }

        /// <summary>
        /// Signals a single true if the source IFlux sequence contains any elements (i.e., it's not empty).
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<bool> HasElements<T>(this IFlux<T> source)
        {
            // TODO implement HasElements
            throw new NotImplementedException();
        }

        /// <summary>
        /// Hides the external and internal identity of the source sequence; useful
        /// to break identity based macro- and micro-optimizations.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Hide<T>(this IFlux<T> source)
        {
            return new PublisherHide<T>(source);
        }

        /// <summary>
        /// Ignores OnNext signals from the source and only relays the terminal signals.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux to ignore elements of.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> IgnoreElements<T>(this IFlux<T> source)
        {
            return new PublisherIgnoreElements<T>(source);
        }

        /// <summary>
        /// Returns the last element from the source sequence or signal IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> Last<T>(this IFlux<T> source)
        {
            // TODO implement Last
            throw new NotImplementedException();
        }

        /// <summary>
        /// Maps the Exception in the OnError signal via a mapper function.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives the Exception from the source and returns an Exception in exchange.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> MapError<T>(this IFlux<T> source, Func<Exception, Exception> mapper)
        {
            return MapError(source, e => true, mapper);
        }

        /// <summary>
        /// Maps the Exception in the OnError signal, if it is of the specified type, via a mapper function.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="E">The Exception type to map.</typeparam>
        /// <param name="source">The source value type.</param>
        /// <param name="mapper">The function that is called if the upstream Exception is of the specified 
        /// type and returns an Exception in exchange.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> MapError<T, E>(this IFlux<T> source, Func<E, Exception> mapper) where E : Exception
        {
            return MapError(source, e => e is E, e => mapper(e as E));
        }

        /// <summary>
        /// Maps the Exception in the OnError signal, if it matches a predicate, via a mapper function.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate called with the upstream Exception and if returns true, the <paramref name="mapper"/> is called.</param>
        /// <param name="mapper">The function called with the upstream Exception, if the predicate matched, and returns an Exception in exchange.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> MapError<T>(this IFlux<T> source, Func<Exception, bool> predicate, Func<Exception, Exception> mapper)
        {
            // TODO implement MapError
            throw new NotImplementedException();
        }

        /// <summary>
        /// Converts the signal types of the source IFlux into ISignal elements.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux with ISignal element type.</returns>
        public static IFlux<ISignal<T>> Materialize<T>(this IFlux<T> source)
        {
            // TODO implement Materialize
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merges the elements of the source IFlux with the other IPublisher into a single, flat sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> MergeWith<T>(this IFlux<T> source, IPublisher<T> other)
        {
            // TODO implement MergeWith
            throw new NotImplementedException();
        }

        /// <summary>
        /// Dispatches the source items in a round-robin fashion to multiple parallel groups, applies a transformation
        /// function on each group and merges them back into a single sequence.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="concurrency">The number of parallel groups.</param>
        /// <param name="mapper">The function that maps each group into an IPublisher output.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Multiplex<T, R>(this IFlux<T> source, int concurrency, Func<IGroupedFlux<int, T>, IPublisher<R>> mapper)
        {
            // TODO implement Multiplex
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals the first element, if any, from the source IFlux.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> Next<T>(this IFlux<T> source)
        {
            // TODO implement Last
            throw new NotImplementedException();
        }

        /// <summary>
        /// Runs the source sequence in unbounded mode and buffers elements until the
        /// downstream requests more.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnBackpressureBuffer<T>(this IFlux<T> source)
        {
            // TODO implement OnBackpressureBuffer
            throw new NotImplementedException();
        }

        /// <summary>
        /// Runs the source sequence in unbounded mode and drops elements if the
        /// downstream didn't request enough or in time.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="onDrop">The action to call with the dropped element.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnBackpressureDrop<T>(this IFlux<T> source, Action<T> onDrop = null)
        {
            // TODO implement OnBackpressureDrop
            throw new NotImplementedException();
        }

        /// <summary>
        /// Runs the source sequence in unbounded mode and signals an InvalidOperationException
        /// if the downstream didn't request enough or in time.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnBackpressureError<T>(this IFlux<T> source)
        {
            return OnBackpressureDrop(source, e => { throw BackpressureHelper.MissingBackpressureException(); });
        }

        /// <summary>
        /// Runs the sequence in unbounded mode and signals the latest element from it
        /// when teh downstream requests. Unclaimed elements are overwritten.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnBackpressureLatest<T>(this IFlux<T> source)
        {
            // TODO implement OnBackpressureLatest
            throw new NotImplementedException();
        }

        /// <summary>
        /// If the source signals an OnError, call the supplied function with the Exception and continue
        /// with the returned IPublisher sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="resumeFunction">The function that receives the Exception and returns an IPublisher for continuing the sequence.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnErrorResumeWith<T>(this IFlux<T> source, Func<Exception, IPublisher<T>> resumeFunction)
        {
            return OnErrorResumeWith(source, e => true, resumeFunction);
        }

        /// <summary>
        /// If the source signals an OnError with an Exception of the given type, call the supplied 
        /// function with the Exception and continue with the returned IPublisher sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="E">The exception type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="resumeFunction">The function that receives the Exception of the specified type
        /// and returns an IPublisher for continuing the sequence.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnErrorResumeWith<T, E>(this IFlux<T> source, Func<E, IPublisher<T>> resumeFunction) where E : Exception
        {
            return OnErrorResumeWith(source, e => e is E, e => resumeFunction(e as E));
        }

        /// <summary>
        /// If the source signals an OnError and the Exception matches a predicate, call the supplied function 
        /// with the Exception and continue with the returned IPublisher sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate called with the OnError Exception and returns true if the <paramref name="resumeFunction"/>
        /// can be called with that Exception.</param>
        /// <param name="resumeFunction">The function that receives the Exception and returns an IPublisher for continuing the sequence.</param>
        /// <returns>The new IFlux instance.</returns>

        public static IFlux<T> OnErrorResumeWith<T>(this IFlux<T> source, Func<Exception, bool> predicate, Func<Exception, IPublisher<T>> resumeFunction)
        {
            // TODO implement OnErrorResumeWith
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals a last value and completes the sequence in place of an OnError signal.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="value">The value to signal at last instead of an OnError.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnErrorReturn<T>(this IFlux<T> source, T value)
        {
            return OnErrorReturn(source, e => true, value);
        }

        /// <summary>
        /// Signals a last value and completes the sequence in place of an OnError signal whose Exception type
        /// matches the specified type.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="E">The exception type to match.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="value">The value to signal at last instead of an OnError.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnErrorReturn<T, E>(this IFlux<T> source, T value) where E : Exception
        {
            return OnErrorReturn(source, e => e is E, value);
        }

        /// <summary>
        /// Signals a last value and completes the sequence in place of an OnError signal in case
        /// the Exception matches the given predicate.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate called with the Exception and if it returns true, the sequence is terminated
        /// with the <paramref name="value"/>.</param>
        /// <param name="value">The value to signal at last instead of an OnError.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnErrorReturn<T>(this IFlux<T> source, Func<Exception, bool> predicate, T value)
        {
            // TODO implement OnErrorReturn
            throw new NotImplementedException();
        }

        /// <summary>
        /// Detaches the references between the upstream and downstream (the upstreams ISubscription
        /// and the downstreams ISubscriber), allowing both to be garbage collected early.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> OnTerminateDetach<T>(this IFlux<T> source)
        {
            // TODO implement OnTerminateDetach
            throw new NotImplementedException();
        }

        /// <summary>
        /// Partitions (groups) the source elements into distinct sub-sequences based on their
        /// hashCode modulo the <see cref="Environment.ProcessorCount"/>. The group key
        /// is the value of the modulo.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<int, T>> Partition<T>(this IFlux<T> source)
        {
            return Partition(source, Environment.ProcessorCount);
        }

        /// <summary>
        /// Partitions (groups) the source elements into distinct sub-sequences based on their
        /// hashCode modulo the specified number of partitions. The group key
        /// is the value of the modulo.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="partitions">The number of partitions.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IGroupedFlux<int, T>> Partition<T>(this IFlux<T> source, int partitions)
        {
            // TODO implement Partition
            throw new NotImplementedException();
        }

        /// <summary>
        /// Drive the source sequence through the given processor when the connection is established
        /// via <see cref="IConnectableFlux{T}.Connect(Action{IDisposable})"/> call to the returned
        /// IConnectableFlux. Note that this is may be a one-time operation depeneding on
        /// how the processor handles terminal signals.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="processor">The processor to signal the events at and subscribe to.</param>
        /// <returns>The new IConnectableFlux instance</returns>
        public static IConnectableFlux<T> Process<T>(this IFlux<T> source, IProcessor<T, T> processor)
        {
            return Process(source, () => processor);
        }

        /// <summary>
        /// Drive the source sequence through the a processor returned by a supplier 
        /// when the connection is established
        /// via <see cref="IConnectableFlux{T}.Connect(Action{IDisposable})"/> call to the returned
        /// IConnectableFlux. 
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="processorSupplier">The function called for each subscriber to return an IProcessor to run elements through.</param>
        /// <returns>The new IConnectableFlux instance</returns>
        public static IConnectableFlux<T> Process<T>(this IFlux<T> source, Func<IProcessor<T, T>> processorSupplier)
        {
            // TODO implement Process
            throw new NotImplementedException();
        }

        /// <summary>
        /// Drive the source sequence through the given processor and an IPublisher returned by
        /// the selector function when the connection is established
        /// via <see cref="IConnectableFlux{T}.Connect(Action{IDisposable})"/> call to the returned
        /// IConnectableFlux. Note that this is may be a one-time operation depeneding on
        /// how the processor handles terminal signals.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="U">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="processor">The processor to signal the events at and subscribe to.</param>
        /// <param name="selector">The function that receives the processor and returns an IPublisher to be the output.</param>
        /// <returns>The new IConnectableFlux instance</returns>
        public static IConnectableFlux<T> Process<T, U>(this IFlux<T> source, IProcessor<T, T> processor, Func<IFlux<T>, IPublisher<U>> selector)
        {
            return Process(source, () => processor, selector);
        }

        /// <summary>
        /// Drive the source sequence through the a processor returned by a supplier and
        /// an IPublisher returned by the selector function when the connection is established
        /// via <see cref="IConnectableFlux{T}.Connect(Action{IDisposable})"/> call to the returned
        /// IConnectableFlux. 
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="U">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="processorSupplier">The function called for each subscriber to return an IProcessor to run elements through.</param>
        /// <param name="selector">The function that receives the processor returned by <paramref name="processorSupplier"/> and returns an IPublisher to be the output.</param>
        /// <returns>The new IConnectableFlux instance</returns>
        public static IConnectableFlux<T> Process<T, U>(this IFlux<T> source, Func<IProcessor<T, T>> processorSupplier, 
            Func<IFlux<T>, IPublisher<U>> selector)
        {
            // TODO implement Process
            throw new NotImplementedException();
        }

        /// <summary>
        /// Shares an underlying connection to the source and dispatches signals to all subscribers currently
        /// subscribed to it.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IConnectableFlux instance.</returns>
        public static IConnectableFlux<T> Publish<T>(this IFlux<T> source)
        {
            return Publish(source, BufferSize);
        }

        /// <summary>
        /// Shares an underlying connection to the source and dispatches signals to all subscribers currently
        /// subscribed to it.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IConnectableFlux instance.</returns>
        public static IConnectableFlux<T> Publish<T>(this IFlux<T> source, int prefetch)
        {
            // TODO implement Publish
            throw new NotImplementedException();
        }

        /// <summary>
        /// Shares a single underlying connection, for each downstream subscriber, to the source 
        /// IFlux for the duration of the transformer function and emits the signals of the returned
        /// IPublisher of this transformer function.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="transformer">The function that receives a shared IFlux instance that can
        /// be freely subscribed to as many times as wanted without causing multiple subscriptions to <paramref name="source"/>
        /// and returns an IPublisher to be the signaller of the resulting signals.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Publish<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> transformer)
        {
            return Publish(source, transformer, BufferSize);
        }

        /// <summary>
        /// Shares a single underlying connection, for each downstream subscriber, to the source 
        /// IFlux for the duration of the transformer function and emits the signals of the returned
        /// IPublisher of this transformer function.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="transformer">The function that receives a shared IFlux instance that can
        /// be freely subscribed to as many times as wanted without causing multiple subscriptions to <paramref name="source"/>
        /// and returns an IPublisher to be the signaller of the resulting signals.</param>
        /// <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> Publish<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> transformer, int prefetch)
        {
            // TODO implement Publish
            throw new NotImplementedException();
        }

        /// <summary>
        /// Prepare an IMono which shares the source IFlux
        /// sequence and dispatches the first observed item to
        /// subscribers in a backpressure-aware manner.
        /// This will effectively turn any type of sequence into a hot sequence 
        /// when the first ISubscriber subscribes.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> PublishNext<T>(this IFlux<T> source)
        {
            // TODO implement PublishNext
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals the events of the source IFlux on the specified scheduler, that is,
        /// the observation of that events downstream will happen on the thread provided
        /// by the scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="scheduler">The Scheduler to use to emit signals on.</param>
        /// <param name="delayError">If true, OnError signals won't skip ahead of the OnNext signals.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> PublishOn<T>(this IFlux<T> source, Scheduler scheduler, bool delayError = true)
        {
            return PublishOn(source, scheduler, BufferSize, delayError);
        }

        /// <summary>
        /// Signals the events of the source IFlux on the specified scheduler, that is,
        /// the observation of that events downstream will happen on the thread provided
        /// by the scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="scheduler">The Scheduler to use to emit signals on.</param>
        /// <param name="prefetch">The number of items to prefetch from the source. If negative, the source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <param name="delayError">If true, OnError signals won't skip ahead of the OnNext signals.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> PublishOn<T>(this IFlux<T> source, Scheduler scheduler, int prefetch, bool delayError = true)
        {
            return new PublisherPublishOn<T>(source, scheduler, delayError, prefetch);
        }

        /// <summary>
        /// Reduces the sequence of values into a single value by applying a reducer function
        /// to a running accumulator value and a current value.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="reducer">The function that receives the previous accumulator value (or the first value) 
        /// and the current value and returns a new accumulator value.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> Reduce<T>(this IFlux<T> source, Func<T, T, T> reducer)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        /// <summary>
        /// Reduces a sequence of values into a single value by starting from an initial
        /// accumulator value and applying a reducer function to the running
        /// accumulator value and the current source element.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="A">The accumulated value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="initial">The initial accumulator value.</param>
        /// <param name="reducer">The function that receives the current accumulator value, the current source element
        /// and returns a new accumulator value.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<A> Reduce<T, A>(this IFlux<T> source, A initial, Func<A, T, A> reducer)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        /// <summary>
        /// Reduces a sequence of values into a single value by starting from an initial
        /// accumulator value supplied by a function and applying a reducer function to the running
        /// accumulator value and the current source element.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="A">The accumulated value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="initialSupplier">The function that returns initial accumulator value for each subscriber.</param>
        /// <param name="reducer">The function that receives the current accumulator value, the current source element
        /// and returns a new accumulator value.</param>
        /// <returns>The new IMono instance.</returns>
        public static IFlux<A> ReduceWith<T, A>(this IFlux<T> source, Func<A> initialSupplier, Func<A, T, A> reducer)
        {
            // TODO implement ReduceWith
            throw new NotImplementedException();
        }

        /// <summary>
        /// Repeatedly subscribes to the source sequence and relays its signals if
        /// it completes normally.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Repeat<T>(this IFlux<T> source)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        /// <summary>
        /// Repeatedly, but at most <paramref name="times"/>, subscribes to the source sequence and relays its signals if
        /// it completes normally.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="times">Number of times to repeat, 0 means run the source once.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Repeat<T>(this IFlux<T> source, long times)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        /// <summary>
        /// Repeatedly subscribes to the source sequence and relays its signals if
        /// it completes normally and the predicate returns true.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate to call when the source completes normally to determine if a repeat should happen.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Repeat<T>(this IFlux<T> source, Func<bool> predicate)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        /// <summary>
        /// Repeatedly subscribes to the source sequence and relays its signals if
        /// it completes normally and the predicate returns true and at most <paramref name="times"/>.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="times">Number of times to repeat, 0 means run the source once.</param>
        /// <param name="predicate">The predicate to call when the source completes normally to determine if a repeat should happen.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Repeat<T>(this IFlux<T> source, long times, Func<bool> predicate)
        {
            // TODO implement Repeat
            throw new NotImplementedException();
        }

        /// <summary>
        /// Repeatedly subscribes to the source when the source completes normally and 
        /// the IPublisher returned by the <paramref name="whenFunction"/>
        /// signals any OnNext value. Any other signals from this IPublisher terminates
        /// the sequence with that signal type.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="whenFunction">The function that receives an IFlux that signals the number
        /// of items emitted in the previous run and returns an IPublisher that has to signal
        /// OnNext to repeat the subscription to the source or a terminal event to terminate the
        /// whole sequence.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> RepeatWhen<T>(this IFlux<T> source, Func<IFlux<long>, IPublisher<object>> whenFunction)
        {
            // TODO implement RepeatWhen
            throw new NotImplementedException();
        }

        /// <summary>
        /// Replays all of the signals of the source IFlux from the very beginning to subscribers.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <returns>The new IConnectableFlux instance.</returns>
        public static IConnectableFlux<T> Replay<T>(this IFlux<T> source)
        {
            // TODO implement Replay
            throw new NotImplementedException();
        }

        /// <summary>
        /// Replays the last specified number of items plus the terminal signal from the IFlux
        /// to subscribers.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="history">The number of last items to replay.</param>
        /// <returns>The new IConnectableFlux instance.</returns>
        public static IConnectableFlux<T> Replay<T>(this IFlux<T> source, int history)
        {
            // TODO implement Replay
            throw new NotImplementedException();
        }

        /// <summary>
        /// Shares a single underlying connection, established for each subscriber, to
        /// the underlying source and applies a transformation function to derive the
        /// output sequence.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="transformer">The function that receives a shared IFlux instance that can
        /// be freely subscribed to as many times as wanted without causing multiple subscriptions to <paramref name="source"/>
        /// and returns an IPublisher to be the signaller of the resulting signals.</param>
        /// <returns>THe new IFlux instance.</returns>
        public static IFlux<R> Replay<T, R>(this IFlux<T> source, Func<IFlux<T>, IPublisher<R>> transformer)
        {
            // TODO implement Replay
            throw new NotImplementedException();
        }

        /// <summary>
        /// Retries the given source IFlux if it signals any OnError.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Retry<T>(this IFlux<T> source)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        /// <summary>
        /// Retries the given source IFlux if it signals any OnError at most the
        /// specified number of times.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="times">The retry amount, 0 retry means don't retry on error.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Retry<T>(this IFlux<T> source, long times)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        /// <summary>
        /// Retries the given source IFlux if it signals any OnError if
        /// the predicate returns true.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The function to return true to retry the source in case of an OnError signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Retry<T>(this IFlux<T> source, Func<Exception> predicate)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        /// <summary>
        /// Retries the given source IFlux if it signals any OnError if
        /// the predicate returns true and at most the specified number of
        /// times.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="times">The retry amount, 0 retry means don't retry on error.</param>
        /// <param name="predicate">The function to return true to retry the source in case of an OnError signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Retry<T>(this IFlux<T> source, long times, Func<Exception> predicate)
        {
            // TODO implement Retry
            throw new NotImplementedException();
        }

        /// <summary>
        /// Retries the source if the IPublisher returned by the <paramref name="whenFunction"/> signals
        /// an OnNext value.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="whenFunction">Function that is called for each subscriber with a IFlux
        /// that emits the OnError signal from the source and returns an IPublisher. If this IPublisher signals
        /// an OnNext, the source is retried or if it signals a terminal event, the sequence is terminated.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> RetryWhen<T>(this IFlux<T> source, Func<IFlux<Exception>, IPublisher<object>> whenFunction)
        {
            // TODO implement RepeatWhen
            throw new NotImplementedException();
        }

        /// <summary>
        /// Samples the latest value from the source IFlux at the specified time intervals.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time interval to sample the source. If the source is
        /// empty at that point, nothing is emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Sample<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Sample(source, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Samples the latest value from the source IFlux at the specified time intervals run
        /// by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time interval to sample the source. If the source is
        /// empty at that point, nothing is emitted.</param>
        /// <param name="scheduler">The timed scheduler to do the periodic sampling and
        /// emission of the sampled value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Sample<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        /// <summary>
        /// Samples the latest value from the source IFlux whenever the other IPublisher signals an OnNext.
        /// </summary>
        /// <typeparam name="T">The main value type.</typeparam>
        /// <typeparam name="U">The other value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="sampler">The sampler IPublisher.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Sample<T, U>(this IFlux<T> source, IPublisher<U> sampler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        /// <summary>
        /// Samples the first values from the source IFlux at the specified time intervals.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The sampling time interval.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SampleFirst<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return SampleFirst(source, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Samples the first values from the source IFlux at the specified time intervals,
        /// running on the specified timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The sampling time interval.</param>
        /// <param name="scheduler">The timed scheduler to do the periodic sampling and
        /// emission of the sampled value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SampleFirst<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        /// <summary>
        /// Samples a values from the source IFlux and ignores subsequent values until the sampler
        /// generated for the sampled value signals an OnNext or OnComplete.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The sampler value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="samplerFactory">The function that takes the sampled value and returns an IPublisher that
        /// has to signal an OnNext or OnComplete to allow the sampling of the next source value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SampleFirst<T, U>(this IFlux<T> source, Func<T, IPublisher<U>> samplerFactory)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals (debounces) the latest OnNext value if no new OnNext value is signalled from the source IFlux
        /// in the specified timespan.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time to wait after an OnNext signal from the source.</param>
        /// <returns>THe new IFlux instance.</returns>
        public static IFlux<T> SampleTimeout<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return SampleTimeout(source, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Signals (debounces) the latest OnNext value if no new OnNext value is signalled from the source IFlux
        /// in the specified timespan, run on the specified timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time to wait after an OnNext signal from the source.</param>
        /// <param name="scheduler">The timed scheduler to do the periodic sampling and
        /// emission of the sampled value.</param>
        /// <returns>THe new IFlux instance.</returns>
        public static IFlux<T> SampleTimeout<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals (debounces) the latest OnNext signal from the source IFlux if no other OnNext signals arrive
        /// from the source during the time the associated IPublisher signals an OnNext or OnComplete.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The sampler value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="samplerFactory">The function called with the source value and returns an IPublisher which
        /// emits that source value when it signals an OnNext or OnComplete and the source didn't signal a new OnNext
        /// in the meantime.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SampleTimeout<T, U>(this IFlux<T> source, Func<T, IPublisher<U>> samplerFactory)
        {
            // TODO implement Sample
            throw new NotImplementedException();
        }

        /// <summary>
        /// Performs a running aggregation on the source IFlux via a scanner function and emits the
        /// intermediate values.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="scanner">The function receiving the accumulated value (or the first source value) and
        /// the current value and returns a new accumulated value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Scan<T>(this IFlux<T> source, Func<T, T, T> scanner)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        /// <summary>
        /// Performs a running aggregation on the source IFlux via a scanner function and emits the
        /// intermediate values, starting with an initial accumulator value.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="A">The accumulator and result type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="initial">The initial accumulator value. Note this is shared across all subscribers.</param>
        /// <param name="scanner">The function receiving the accumulated value (or the initial value) and
        /// the current value and returns a new accumulated value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<A> Scan<T, A>(this IFlux<T> source, A initial, Func<A, T, A> scanner)
        {
            // TODO implement Reduce
            throw new NotImplementedException();
        }

        /// <summary>
        /// Performs a running aggregation on the source IFlux via a scanner function and emits the
        /// intermediate values, starting with an initial accumulator value for each subscriber.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="A">The accumulator and result type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="initialSupplier">The function that generates the initial accumulator value for each subscriber.</param>
        /// <param name="scanner">The function receiving the accumulated value (or the initial value) and
        /// the current value and returns a new accumulated value.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<A> ScanWith<T, A>(this IFlux<T> source, Func<A> initialSupplier, Func<A, T, A> scanner)
        {
            // TODO implement ReduceWith
            throw new NotImplementedException();
        }

        /// <summary>
        /// Expects the source to be single-valued and returns an IMono for it. If
        /// the source is empty or has more than one element, an IndexOutOfRangeException is
        /// signalled.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> Single<T>(this IFlux<T> source)
        {
            // TODO implement Single
            throw new NotImplementedException();
        }

        /// <summary>
        /// Expects the source to be zero or single-valued and returns an IMono for it. If
        /// the source is empty, the given defaultValue is signalled. If the source has more 
        /// than one element, an IndexOutOfRangeException is signalled.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="defaultValue">The value to signal if the source is empty.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> Single<T>(this IFlux<T> source, T defaultValue)
        {
            // TODO implement Single
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals the single value or OnComplete if the source has exactly one item or is empty, or
        /// signals an IndexOutOfRangeException if the source has more than one item.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> SingleOrEmpty<T>(this IFlux<T> source)
        {
            // TODO implement Single
            throw new NotImplementedException();
        }

        /// <summary>
        /// Skips the first number of items from the source IFlux sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="n">The number of items to skip from the beginning.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Skip<T>(this IFlux<T> source, long n)
        {
            if (n <= 0L)
            {
                return source;
            }
            return new PublisherSkip<T>(source, n);
        }

        /// <summary>
        /// Skips items from the beginning source IFlux during the specified timespan.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time duration while to skip the items from the source.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Skip<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Skip(source, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Skips items from the beginning source IFlux during the specified timespan
        /// as run on the specified timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The time duration while to skip the items from the source.</param>
        /// <param name="scheduler">The timed scheduler to use for the timed skipping.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Skip<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Skip
            throw new NotImplementedException();
        }

        /// <summary>
        /// Skips the last given number of items from the source IFlux.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="n">The number of last items to skip.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SkipLast<T>(this IFlux<T> source, long n)
        {
            // TODO implement SkipLast
            throw new NotImplementedException();
        }

        /// <summary>
        /// Skips items from the source IFlux until the other IPublisher signals an
        /// OnNext or OnComplete signal.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The other value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher that signals OnNext or OnComplete, allowing the subsequent
        /// main source items to flow through.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SkipUntil<T, U>(this IFlux<T> source, IPublisher<U> other)
        {
            // TODO implement SkipUntil
            throw new NotImplementedException();
        }

        /// <summary>
        /// Skips the first items while the predicate returns true for them.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate called with the current item and returns true to skip that item.
        /// If it returns false, all subsequent items from the source are passed along without futher calls to this predicate.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SkipWhile<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement SkipWhile
            throw new NotImplementedException();
        }

        /// <summary>
        /// Emits the given items before the source IFlux.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="values">The values to signal before the source IFlux items.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> StartWith<T>(this IFlux<T> source, params T[] values)
        {
            return StartWith<T>(source, From(values), false);
        }

        /// <summary>
        /// Emits items from an IEnumerable before the source IFlux.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="values">The values to signal before the source IFlux items.</param>
        /// <param name="delayError">Should any error of the IEnumerable be delayed after the termination of the source IFlux?</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> StartWith<T>(this IFlux<T> source, IEnumerable<T> values, bool delayError = false)
        {
            return StartWith<T>(source, From(values), delayError);
        }

        /// <summary>
        /// Emits items from the other IPublisher before the source IFlux.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher whose values have to be signalled before the source IFlux.</param>
        /// <param name="delayError">Should any error of the IPublisher be delayed after the termination of the source IFlux?</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> StartWith<T>(this IFlux<T> source, IPublisher<T> other, bool delayError = false)
        {
            if (source is PublisherConcatArray<T>)
            {
                return (source as PublisherConcatArray<T>).StartWith(source, delayError);
            }
            return new PublisherConcatArray<T>(new IPublisher<T>[] { source, other }, delayError);
        }

        /// <summary>
        /// Calls Subscribe() and Request() of the source IFlux on a thread provided by the specified scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="scheduler">The scheduler that provides the thread to call Subscribe() and Request() on.</param>
        /// <returns>The new IFlux isntance.</returns>
        public static IFlux<T> SubscribeOn<T>(this IFlux<T> source, Scheduler scheduler)
        {
            // TODO implement SubscribeOn
            throw new NotImplementedException();
        }

        /// <summary>
        /// Switches to a new inner IPublisher, generated by a mapper function, whenever the source
        /// emits an OnNext, cancelling the previous IPublisher if any.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives the source item and returns an IPublisher whose items are then 
        /// relayed until the main source signals another item.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> SwitchMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper)
        {
            return SwitchMap(source, mapper, BufferSize);
        }

        /// <summary>
        /// Switches to a new inner IPublisher, generated by a mapper function, whenever the source
        /// emits an OnNext, cancelling the previous IPublisher if any.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="R">The output value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="mapper">The function that receives the source item and returns an IPublisher whose items are then 
        /// relayed until the main source signals another item.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> SwitchMap<T, R>(this IFlux<T> source, Func<T, IPublisher<R>> mapper, int prefetch)
        {
            return new PublisherSwitchMap<T, R>(source, mapper, prefetch);
        }

        /// <summary>
        /// Switches to the other IPublisher if the source turns out to be empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher to resume with if the source is empty.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> SwitchIfEmpty<T>(this IFlux<T> source, IPublisher<T> other)
        {
            // TODO implement SwitchIfEmpty
            throw new NotImplementedException();
        }

        /// <summary>
        /// Takes the first number of items from the source and completes the sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="n">The number of items to take from the beginning.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Take<T>(this IFlux<T> source, long n)
        {
            return new PublisherTake<T>(source, n);
        }

        /// <summary>
        /// Takes the items from the beginning during the specified timespan interval.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The duration timespan to allow source items to pass through.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Take<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Take(source, timespan);
        }


        /// <summary>
        /// Takes the items from the beginning during the specified timespan interval,
        /// run on the specified timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">The duration timespan to allow source items to pass through.</param>
        /// <param name="scheduler">The timed scheduler to use for timing the duration.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Take<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Take
            throw new NotImplementedException();
        }

        /// <summary>
        /// Signals the last number of items only from the source IFlux.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="n">The number of last items to signal.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> TakeLast<T>(this IFlux<T> source, long n)
        {
            // TODO implement TakeLast
            throw new NotImplementedException();
        }

        /// <summary>
        /// Allows elements from the source IFlux to pass through until the 
        /// other IPublisher signals an OnNext or OnComplete which completes the
        /// sequence.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The other value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher that signals an OnNext or OnComplete to stop the main source .</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> TakeUntil<T, U>(this IFlux<T> source, IPublisher<U> other)
        {
            // TODO implement TakeUntil
            throw new NotImplementedException();
        }

        /// <summary>
        /// Allows elements from the source IFlux to pass through and checks the predicate
        /// to stop the sequence or not.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate called after the emission of each source item, with
        /// that item and returns true if the sequence has to be completed.</param>
        /// <returns></returns>
        public static IFlux<T> TakeUntil<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement TakeUntil
            throw new NotImplementedException();
        }

        /// <summary>
        /// Allows elements to pass through if the predicate, called before emission, returns true for that element
        /// or stops if the predicate returns false.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="predicate">The predicate called before emission with the current element from
        /// the source and if returns true, the element is signalled. Otherwise, the sequence is completed.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> TakeWhile<T>(this IFlux<T> source, Func<T, bool> predicate)
        {
            // TODO implement TakeWhile
            throw new NotImplementedException();
        }

        /// <summary>
        /// Returns an IMono that signals only the terminal signals from the source IFlux.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<T> Then<T>(this IFlux<T> source)
        {
            // TODO implement Then
            throw new NotImplementedException();
        }

        /// <summary>
        /// Runs the other, empty IPublisher instance when the source IFlux completes,
        /// ignoring their values and only signalling the terminal events.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher.</param>
        /// <returns>The new IMono instance.</returns>
        public static IMono<Void> Then<T>(this IFlux<T> source, IPublisher<Void> other)
        {
            // TODO implement Then
            throw new NotImplementedException();
        }

        /// <summary>
        /// Runs the source IFlux to completion, ignoring its elements, then relays elements of
        /// the after IPublisher.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="after">The IPublisher to run and relay signals of after the source.</param>
        /// <returns></returns>
        public static IFlux<T> ThenMany<T>(this IFlux<T> source, IPublisher<T> after)
        {
            // Can't fuse multiple applications into one operator unless all the types are the same due to non-erasure, unlike Java.
            return ThenMany<T, T>(source, after);
        }

        /// <summary>
        /// Runs the source IFlux to completion, ignoring its elements, then relays elements of
        /// the after IPublisher.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The after value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="after">The IPublisher to run and relay signals of after the source.</param>
        /// <returns></returns>
        public static IFlux<R> ThenMany<T, R>(this IFlux<T> source, IPublisher<R> after)
        {
            // TODO implement ThenMany
            throw new NotImplementedException();
        }

        /// <summary>
        /// If the source doesn't produce subsequent items within the specified timeout, the
        /// sequence is switched to a fallback IPublisher or a TimeoutException is signalled.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timeout">The timeout between source items.</param>
        /// <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Timeout<T>(this IFlux<T> source, TimeSpan timeout, IPublisher<T> fallback = null)
        {
            return Timeout(source, timeout, DefaultScheduler.Instance);
        }

        /// <summary>
        /// If the source doesn't produce subsequent items within the specified timeout, the
        /// sequence is switched to a fallback IPublisher or a TimeoutException is signalled,
        /// where the timeout is determined by the given timed scheduler.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timeout">The timeout between source items.</param>
        /// <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
        /// <param name="scheduler">The timed scheduler giving the notion of the timeout.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Timeout<T>(this IFlux<T> source, TimeSpan timeout, TimedScheduler scheduler, IPublisher<T> fallback = null)
        {
            // TODO implement Timeout
            throw new NotImplementedException();
        }

        /// <summary>
        /// If the source doesn't produce its first item before the other IPublisher signals an OnNext or
        /// OnComplete, the sequence is switched to the fallback IPublisher or a TimeoutException is signalled.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The first timeout value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="firstTimeout">The timeout signaller for the first source item.</param>
        /// <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Timeout<T, U>(this IFlux<T> source, IPublisher<U> firstTimeout, IPublisher<T> fallback = null)
        {
            // TODO implement Timeout
            throw new NotImplementedException();
        }

        /// <summary>
        /// If the source doesn't signal its first or subsequent items before the associated timeout IPublishers
        /// signal an OnNext or OnError, the sequence is switched to the fallback IPublisher or a TimeoutException is signalled.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The first timeout value type.</typeparam>
        /// <typeparam name="V">The subsequent timeout value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="firstTimeout">The timeout signaller for the first source item.</param>
        /// <param name="fallback">The fallback IPublisher if the source times out. If null, a TimeoutException is signalled.</param>
        /// <param name="itemTimeout">The function receives the previous source value and returns an IPublisher which signals
        /// timeout via OnNext or OnComplete.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> Timeout<T, U, V>(this IFlux<T> source, IPublisher<U> firstTimeout, Func<T, IPublisher<V>> itemTimeout, IPublisher<T> fallback = null)
        {
            // TODO implement Timeout
            throw new NotImplementedException();
        }

        /// <summary>
        /// Wraps each source item into a structure that holds the current time when the item
        /// was received.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<Timed<T>> Timestamp<T>(this IFlux<T> source)
        {
            return Timestamp(source, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Wraps each source item into a structure that holds the current time,
        /// as returned by the given timed scheduler, when the item
        /// was received.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="scheduler">The timed scheduler providing the current time.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<Timed<T>> Timestamp<T>(this IFlux<T> source, TimedScheduler scheduler)
        {
            return Map(source, v => new Timed<T>(v, scheduler.NowUtc));
        }

        /// <summary>
        /// Convert an IObservable into an IFlux and apply a backpressure strategy to the sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="backpressure">The backpressure strategy to apply. See <see cref="BackpressureHandling"/> enums.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<T> ToFlux<T>(this IObservable<T> source, BackpressureHandling backpressure = BackpressureHandling.Error)
        {
            return From(source, backpressure);
        }

        /// <summary>
        /// Converts this IFlux into an IMono.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source to convert</param>
        /// <returns>The IFlux instance</returns>
        public static IMono<T> ToMono<T>(this IFlux<T> source)
        {
            if (source is IMono<T>)
            {
                return source as IMono<T>;
            }
            // TODO implement ToMono
            throw new NotImplementedException();
        }

        /// <summary>
        /// Convert this IFlux into an IObservable.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IObservable.</returns>
        public static IObservable<T> ToObservable<T>(this IFlux<T> source)
        {
            return new PublisherAsObservable<T>(source);
        }

        /// <summary>
        ///	Split this IFlux sequence into multiple IFlux delimited by the given maxSize
        /// count and starting from the first item.
        ///	Each Flux bucket will onComplete after maxSize items have been routed.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="size">The maximum routed items before emitting onComplete per IFlux bucket.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int size) {
            return Window(source, size, size);
        }

        /// <summary>
        /// Split this IFlux sequence into multiple IFlux delimited by the given {@code skip}
        /// count, starting from the first item.
        /// Each IFlux bucket will onComplete after {@code maxSize} items have been routed.
        /// </summary>
        /// <remarks>
        /// When skip > maxSize : dropping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskip.png" alt=""/>
        /// <p/>
        /// When maxSize &lt; skip : overlapping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskipover.png" alt=""/>
        /// <p/>
        /// When skip == maxSize : exact windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsize.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="size">The maximum routed items per IFlux</param>
        /// <param name="skip">The number of items to count before emitting a new bucket IFlux.</param>
        /// <returns>A windowing IFlux of sized IFlux buckets every skip count.</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int size, int skip)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        /// <summary>
        /// Split this IFlux sequence into continuous, non-overlapping windows
        /// where the window boundary is signalled by another IPublisher
        /// </summary>
        /// <remarks>
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowboundary.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The boundary value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="boundary">a IPublisher to emit any item for a split signal and complete to terminate</param>
        /// <returns>a windowing IFlux delimiting its sub-sequences by a given IPublisher</returns>
        public static IFlux<IFlux<T>> Window<T, U>(this IFlux<T> source, IPublisher<U> boundary)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        /// <summary>
        /// Split this IFlux sequence into potentially overlapping windows controlled by items of a
        /// start IPublisher and end IPublisher derived from the start values.
        /// </summary>
        /// <remarks>
        /// <p/>
        /// When Open signal is strictly not overlapping Close signal : dropping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowopenclose.png" alt=""/>
        /// <p/>
        /// When Open signal is strictly more frequent than Close signal : overlapping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowopencloseover.png" alt=""/>
        /// <p/>
        /// When Open signal is exactly coordinated with Close signal : exact windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowboundary.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The type of the sequence opening windows</typeparam>
        /// <typeparam name="V">The type of the sequence closing windows opened by the bucketOpening Publisher's elements</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="open">A IPublisher to emit any item for a split signal and complete to terminate</param>
        /// <param name="close">A function given an opening signal and returning a IPublisher that
        /// emits to complete the window</param>
        /// <returns>A windowing IFlux delimiting its sub-sequences by a given IPublisher and lasting until
        /// a selected IPublisher emits.</returns>
        public static IFlux<IFlux<T>> Window<T, U, V>(this IFlux<T> source, IPublisher<U> open, Func<U, IPublisher<V>> close)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        /// <summary>
        /// Split this IFlux sequence into continuous, non-overlapping windows delimited by a given period.
        /// </summary>
        /// <remarks>
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowtimespan.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">the duration in milliseconds to delimit IFlux windows</param>
        /// <returns>a windowing IFlux of timed IFlux buckets</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan)
        {
            return Window(source, timespan, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Split this IFlux sequence into continuous, non-overlapping windows delimited by a given period.
        /// </summary>
        /// <remark>
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowtimespan.png" alt=""/>
        /// </remark>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">the duration in milliseconds to delimit IFlux windows</param>
        /// <param name="scheduler">The timed scheduler used for providing the timing of the window boundaries.</param>
        /// <returns>a windowing IFlux of timed IFlux buckets</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan, TimedScheduler scheduler)
        {
            return Window(source, timespan, timespan, scheduler);
        }

        /// <summary>
        /// Split this IFlux sequence into multiple IFlux delimited by the given {@code timeshift}
        /// period, starting from the first item.
        /// Each IFlux bucket will onComplete after {@code timespan} period has elpased.
        /// </summary>
        /// <remarks>
        /// <p/>
        /// When timeshift > timespan : dropping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskip.png" alt=""/>
        /// <p/>
        /// When timeshift &lt; timespan : overlapping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskipover.png" alt=""/>
        /// <p/>
        /// When timeshift == timespan : exact windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsize.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">the maximum IFlux window duration in milliseconds</param>
        /// <param name="timeskip">the period of time in milliseconds to create new IFlux windows</param>
        /// <returns>a windowing IFlux of IFlux buckets delimited by an opening IPublisher and a selected closing IPublisher</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip)
        {
            return Window(source, timespan, timeskip, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Split this IFlux sequence into multiple IFlux delimited by the given {@code timeshift}
        /// period, starting from the first item.
        /// Each IFlux bucket will onComplete after {@code timespan} period has elpased.
        /// </summary>
        /// <remarks>
        /// <p/>
        /// When timeshift > timespan : dropping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskip.png" alt=""/>
        /// <p/>
        /// When timeshift &lt; timespan : overlapping windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizeskipover.png" alt=""/>
        /// <p/>
        /// When timeshift == timespan : exact windows
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsize.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="timespan">the maximum IFlux window duration in milliseconds</param>
        /// <param name="timeskip">the period of time in milliseconds to create new IFlux windows</param>
        /// <param name="scheduler">The timed scheduler to run the timed support operations.</param>
        /// <returns>a windowing IFlux of IFlux buckets delimited by an opening IPublisher and a selected closing IPublisher</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, TimeSpan timespan, TimeSpan timeskip, TimedScheduler scheduler)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        /// <summary>
        /// Split this IFlux sequence into multiple IFlux delimited by the given {@code maxSize} number
        /// of items, starting from the first item. IFlux windows will onComplete after a given
        /// timespan occurs and the number of items has not be counted.
        /// </summary>
        /// <remarks>
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizetimeout.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="maxSize">the maximum IFlux window items to count before onComplete</param>
        /// <param name="timespan">the timeout to use to onComplete a given window if size is not counted yet</param>
        /// <returns>a windowing IFlux of sized or timed IFlux buckets</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int maxSize, TimeSpan timespan)
        {
            return Window(source, maxSize, timespan, DefaultScheduler.Instance);
        }

        /// <summary>
        /// Split this IFlux sequence into multiple IFlux delimited by the given {@code maxSize} number
        /// of items, starting from the first item. IFlux windows will onComplete after a given
        /// timespan occurs and the number of items has not be counted.
        /// </summary>
        /// <remarks>
        /// <p/>
        /// <img class="marble" src="https://raw.githubusercontent.com/reactor/projectreactor.io/master/src/main/static/assets/img/marble/windowsizetimeout.png" alt=""/>
        /// </remarks>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="maxSize">the maximum IFlux window items to count before onComplete</param>
        /// <param name="timespan">the timeout to use to onComplete a given window if size is not counted yet</param>
        /// <param name="scheduler">The timed scheduler to run the timed support operations.</param>
        /// <returns>a windowing IFlux of sized or timed IFlux buckets</returns>
        public static IFlux<IFlux<T>> Window<T>(this IFlux<T> source, int maxSize, TimeSpan timespan, TimedScheduler scheduler)
        {
            // TODO implement Window
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines the values from the source IFlux with the latest value from the other IPublisher.
        /// </summary>
        /// <typeparam name="T1">The source value type.</typeparam>
        /// <typeparam name="T2">The other value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher to take the latest value from.</param>
        /// <param name="combiner">The function receiving the current source item and the latest value from the other IPublisher
        /// and returns a value to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> WithLatestFrom<T1, T2, R>(this IFlux<T1> source, IPublisher<T2> other, Func<T1, T2, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
        /// </summary>
        /// <typeparam name="T1">The source value type.</typeparam>
        /// <typeparam name="T2">The first other value type.</typeparam>
        /// <typeparam name="T3">The second other value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="p2">The first other IPublisher to take the latest value from.</param>
        /// <param name="p3">The second other IPublisher to take the latest value from.</param>
        /// <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
        /// and returns a value to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> WithLatestFrom<T1, T2, T3, R>(this IFlux<T1> source, 
            IPublisher<T2> p2, IPublisher<T3> p3,
            Func<T1, T2, T3, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
        /// </summary>
        /// <typeparam name="T1">The source value type.</typeparam>
        /// <typeparam name="T2">The first other value type.</typeparam>
        /// <typeparam name="T3">The second other value type.</typeparam>
        /// <typeparam name="T4">The third other value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="p2">The first other IPublisher to take the latest value from.</param>
        /// <param name="p3">The second other IPublisher to take the latest value from.</param>
        /// <param name="p4">The third other IPublisher to take the latest value from.</param>
        /// <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
        /// and returns a value to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> WithLatestFrom<T1, T2, T3, T4, R>(this IFlux<T1> source,
            IPublisher<T2> p2, IPublisher<T3> p3,
            IPublisher<T4> p4,
            Func<T1, T2, T3, T4, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
        /// </summary>
        /// <typeparam name="T1">The source value type.</typeparam>
        /// <typeparam name="T2">The first other value type.</typeparam>
        /// <typeparam name="T3">The second other value type.</typeparam>
        /// <typeparam name="T4">The third other value type.</typeparam>
        /// <typeparam name="T5">The fourth other value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="p2">The first other IPublisher to take the latest value from.</param>
        /// <param name="p3">The second other IPublisher to take the latest value from.</param>
        /// <param name="p4">The third other IPublisher to take the latest value from.</param>
        /// <param name="p5">The fourth other IPublisher to take the latest value from.</param>
        /// <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
        /// and returns a value to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> WithLatestFrom<T1, T2, T3, T4, T5, R>(this IFlux<T1> source,
            IPublisher<T2> p2, IPublisher<T3> p3,
            IPublisher<T4> p4, IPublisher<T5> p5,
            Func<T1, T2, T3, T4, T5, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
        /// </summary>
        /// <typeparam name="T1">The source value type.</typeparam>
        /// <typeparam name="T2">The first other value type.</typeparam>
        /// <typeparam name="T3">The second other value type.</typeparam>
        /// <typeparam name="T4">The third other value type.</typeparam>
        /// <typeparam name="T5">The fourth other value type.</typeparam>
        /// <typeparam name="T6">The fifth other value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="p2">The first other IPublisher to take the latest value from.</param>
        /// <param name="p3">The second other IPublisher to take the latest value from.</param>
        /// <param name="p4">The third other IPublisher to take the latest value from.</param>
        /// <param name="p5">The fourth other IPublisher to take the latest value from.</param>
        /// <param name="p6">The fifth other IPublisher to take the latest value from.</param>
        /// <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
        /// and returns a value to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> WithLatestFrom<T1, T2, T3, T4, T5, T6, R>(this IFlux<T1> source,
            IPublisher<T2> p2, IPublisher<T3> p3,
            IPublisher<T4> p4, IPublisher<T5> p5,
            IPublisher<T6> p6,
            Func<T1, T2, T3, T4, T5, T6, R> combiner)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines the values from the source IFlux with the latest value from the multiple other IPublishers.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <typeparam name="R">The result value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="others">The other IPublishers to take the latest value from.</param>
        /// <param name="combiner">The function receiving the current source item and the latest value from the other IPublishers
        /// and returns a value to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> WithLatestFrom<T, R>(this IFlux<T> source, Func<T[], R> combiner, params IPublisher<T>[] others)
        {
            // TODO implement WithLatestFrom
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines rows of elements from the source IFlux and the other IPublisher and emits
        /// the value by the function.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher</param>
        /// <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
        /// to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ZipWith<T, R>(this IFlux<T> source, IPublisher<T> other, Func<T, T, R> zipper)
        {
            return ZipWith<T, R>(source, other, zipper, BufferSize);
        }

        /// <summary>
        /// Combines rows of elements from the source IFlux and the other IPublisher and emits
        /// the value by the function.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="R">The result type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher</param>
        /// <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
        /// to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ZipWith<T, R>(this IFlux<T> source, IPublisher<T> other, Func<T, T, R> zipper, int prefetch)
        {
            // Allows fusing only if all soures have the same type due to no type erasure, unlike Java
            // TODO implement ZipWith
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines rows of elements from the source IFlux and the other IPublisher and emits
        /// the value by the function.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The other value type.</typeparam>
        /// <typeparam name="R">The result type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher</param>
        /// <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
        /// to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ZipWith<T, U, R>(this IFlux<T> source, IPublisher<U> other, Func<T, U, R> zipper)
        {
            return ZipWith<T, U, R>(source, other, zipper, BufferSize);
        }

        /// <summary>
        /// Combines rows of elements from the source IFlux and the other IPublisher and emits
        /// the value by the function.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The other value type.</typeparam>
        /// <typeparam name="R">The result type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IPublisher</param>
        /// <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
        /// to be emitted.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ZipWith<T, U, R>(this IFlux<T> source, IPublisher<U> other, Func<T, U, R> zipper, int prefetch)
        {
            // TODO implement ZipWith
            throw new NotImplementedException();
        }

        /// <summary>
        /// Combines the elements of the source IFlux with the next value from the IEnumerable sequence through
        /// a function.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="U">The IEnumerable's value type.</typeparam>
        /// <typeparam name="R">The result type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="other">The other IEnumerable instance.</param>
        /// <param name="zipper">The function that receives the two next values from the source and other and returns a value in exchange
        /// to be emitted.</param>
        /// <returns>The new IFlux instance.</returns>
        public static IFlux<R> ZipWith<T, U, R>(this IFlux<T> source, IEnumerable<U> other, Func<T, U, R> zipper)
        {
            return new PublisherZipEnumerable<T, U, R>(source, other, zipper);
        }

        // ---------------------------------------------------------------------------------------------------------
        // Leave the reactive world
        // ---------------------------------------------------------------------------------------------------------

        /// <summary>
        /// Subscribe to the source and block until it produces a value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        public static T BlockFirst<T>(this IFlux<T> source)
        {
            var s = new BlockingFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Get(true);
        }

        /// <summary>
        /// Subscribe to the source and block until it produces a value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <param name="timeout">The maximum amount of time to wait for the value.</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        /// <exception cref="TimeoutException">If the source didn't produce any value within the given timeout.</exception>
        public static T BlockFirst<T>(this IFlux<T> source, TimeSpan timeout)
        {
            var s = new BlockingFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Get(timeout, true, true);
        }

        /// <summary>
        /// Subscribe to the source and block until it completes and returns the last value produces a value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        public static T BlockLast<T>(this IFlux<T> source)
        {
            var s = new BlockingLastSubscriber<T>();
            source.Subscribe(s);
            return s.Get(true);
        }

        /// <summary>
        /// Subscribe to the source and block until it completes and returns the last value or
        /// signals an Exception. An empty source will throw an IndexOutOfRangeException.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source</param>
        /// <param name="timeout">The maximum amount of time to wait for the value.</param>
        /// <returns>The value produced</returns>
        /// <exception cref="IndexOutOfRangeException">If the source is empty.</exception>
        /// <exception cref="TimeoutException">If the source didn't produce any value within the given timeout.</exception>
        public static T BlockLast<T>(this IFlux<T> source, TimeSpan timeout)
        {
            var s = new BlockingLastSubscriber<T>();
            source.Subscribe(s);
            return s.Get(timeout, true, true);
        }

        /// <summary>
        /// Subscribes to the IPublisher and ignores all of its signals.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source)
        {
            var d = new CallbackSubscriber<T>(v => { }, e => { ExceptionHelper.OnErrorDropped(e); }, () => { });
            source.Subscribe(d);
            return d;
        }

        /// <summary>
        /// Subscribes to the IPublisher and consumes only its OnNext signals.
        /// </summary>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <param name="onNext">The callback for the OnNext signals</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source, Action<T> onNext)
        {
            var d = new CallbackSubscriber<T>(onNext, e => { ExceptionHelper.OnErrorDropped(e); }, () => { });
            source.Subscribe(d);
            return d;
        }

        /// <summary>
        /// Subscribes to the IPublisher and consumes only its OnNext signals.
        /// </summary>
        /// <remarks>
        /// If the <paramref name="onNext"/> callback crashes, the error is routed
        /// to <paramref name="onError"/> callback.
        /// If the <paramref name="onError"/> callback crashes, the error is routed to the
        /// global error hanlder in <see cref="ExceptionHelper.OnErrorDropped(Exception)"/>.
        /// </remarks>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <param name="onNext">The callback for the OnNext signals</param>
        /// <param name="onError">The callback for the OnError signals</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source, Action<T> onNext, Action<Exception> onError)
        {
            var d = new CallbackSubscriber<T>(onNext, onError, () => { });
            source.Subscribe(d);
            return d;
        }

        /// <summary>
        /// Subscribes to the IPublisher and consumes only its OnNext signals.
        /// </summary>
        /// <remarks>
        /// If the <paramref name="onNext"/> callback crashes, the error is routed
        /// to <paramref name="onError"/> callback.
        /// If the <paramref name="onError"/> or <paramref name="onComplete"/> callbackcrashes, 
        /// the error is routed to the
        /// global error hanlder in <see cref="ExceptionHelper.OnErrorDropped(Exception)"/>.
        /// </remarks>
        /// <typeparam name="T">The value type</typeparam>
        /// <param name="source">The source IPublisher</param>
        /// <param name="onNext">The callback for the OnNext signals.</param>
        /// <param name="onError">The callback for the OnError signal.</param>
        /// <param name="onComplete">The callback for the OnComplete signal.</param>
        /// <returns>The IDisposable that allows cancelling the subscription.</returns>
        public static IDisposable Subscribe<T>(this IFlux<T> source, Action<T> onNext, Action<Exception> onError, Action onComplete)
        {
            var d = new CallbackSubscriber<T>(onNext, onError, onComplete);
            source.Subscribe(d);
            return d;
        }

        /// <summary>
        /// Subscribes with the given subscriber subclass to the source and returns that subscriber instance.
        /// </summary>
        /// <typeparam name="T">The source value type.</typeparam>
        /// <typeparam name="E">The ISubscriber type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="subscriber">The subscriber to subscribe with and to be returned.</param>
        /// <returns>The <paramref name="subscriber"/>.</returns>
        public static E SubscribeWith<T, E>(this IFlux<T> source, E subscriber) where E : ISubscriber<T>
        {
            source.Subscribe(subscriber);
            return subscriber;
        }

        /// <summary>
        /// Converts the source into a blocking IEnumerable sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <returns>The new IEnumerable instance.</returns>
        public static IEnumerable<T> ToEnumerable<T>(this IFlux<T> source)
        {
            return ToEnumerable(source, BufferSize);
        }

        /// <summary>
        /// Converts the source into a blocking IEnumerable sequence.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux.</param>
        /// <param name="prefetch">The number of items to prefetch from each source. If negative, each source is run in
        /// unbounded mode and the absolute amount is used for the link size of the internal unbounded queue.</param>
        /// <returns>The new IEnumerable instance.</returns>
        public static IEnumerable<T> ToEnumerable<T>(this IFlux<T> source, int prefetch)
        {
            return new PublisherAsEnumerable<T>(source, prefetch);
        }

        /// <summary>
        /// Returns a Task that awaits the first item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <returns>The task.</returns>
        public static Task<T> FirstTask<T>(this IFlux<T> source)
        {
            var s = new TaskFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Task();
        }

        /// <summary>
        /// Returns a Task that awaits the first item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The task.</returns>
        public static Task<T> FirstTask<T>(this IFlux<T> source, CancellationToken ct)
        {
            var s = new TaskFirstSubscriber<T>();
            source.Subscribe(s);
            return s.Task(ct);
        }

        /// <summary>
        /// Returns a Task that awaits the last item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <returns>The task.</returns>
        public static Task<T> LastTask<T>(this IFlux<T> source)
        {
            var s = new TaskLastSubscriber<T>();
            source.Subscribe(s);
            return s.Task();
        }

        /// <summary>
        /// Returns a Task that awaits the last item from the IFlux or
        /// signals an IndexOutOfRangeException if the IFlux is empty.
        /// </summary>
        /// <typeparam name="T">The value type.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The task.</returns>
        public static Task<T> LastTask<T>(this IFlux<T> source, CancellationToken ct)
        {
            var s = new TaskLastSubscriber<T>();
            source.Subscribe(s);
            return s.Task(ct);
        }

        /// <summary>
        /// Return a Task that waits for the IMono source to complete.
        /// </summary>
        /// <param name="source">The source IMono</param>
        /// <returns>The task.</returns>
        public static Task WhenCompleteTask<T>(this IFlux<T> source)
        {
            var s = new TaskCompleteSubscriber<T>();
            source.Subscribe(s);
            return s.Task();
        }

        /// <summary>
        /// Return a Task that waits for the IMono source to complete
        /// and support the cancellation of such wait.
        /// </summary>
        /// <param name="source">The source IMono</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The task.</returns>
        public static Task WhenCompleteTask<T>(this IFlux<T> source, CancellationToken ct)
        {
            var s = new TaskCompleteSubscriber<T>();
            source.Subscribe(s);
            return s.Task(ct);
        }

        /// <summary>
        /// Creates a TestSubscriber with the given initial settings and returns it.
        /// </summary>
        /// <typeparam name="T">The value type received.</typeparam>
        /// <param name="source">The source IFlux</param>
        /// <param name="initialRequest">The optional initial request amount.</param>
        /// <param name="fusionMode">The optional fusion mode if supported by the source.</param>
        /// <param name="cancelled">Optionally start out as cancelled.</param>
        /// <returns></returns>
        public static TestSubscriber<T> Test<T>(this IFlux<T> source, long initialRequest = long.MaxValue, int fusionMode = 0, bool cancelled = false)
        {
            TestSubscriber<T> ts = new TestSubscriber<T>(initialRequest, fusionMode);
            if (cancelled)
            {
                ts.Cancel();
            }

            source.Subscribe(ts);

            return ts;
        }

        /// <summary>
        /// Convenience method to signal the given values to the IProcessor.
        /// </summary>
        /// <typeparam name="T">The input value type.</typeparam>
        /// <typeparam name="U">The output value type</typeparam>
        /// <param name="processor">The target processor instance.</param>
        /// <param name="t1">The first value to signal.</param>
        /// <param name="t2">The second value to signal.</param>
        /// <param name="values">The rest of the values to signal.</param>
        public static void OnNext<T, U>(this IProcessor<T, U> processor, T t1, T t2, params T[] values)
        {
            processor.OnNext(t1);
            processor.OnNext(t2);
            foreach (var t in values)
            {
                processor.OnNext(t);
            }
        }
    }
}
